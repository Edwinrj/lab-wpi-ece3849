---
title: "Lab 1 ‚Äî Multi-Screen UI and Code Organization"
description: "Learn how to add sound feedback, navigate between screens, and organize modular code."
---

import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 0"
      description="Make sure you finished Lab 0 before starting."
      href="/labs/lab0/"
      icon="setting"
   />
   <LinkCard
  title="Download Lab 1 Template"
  description="Download the starter code for Lab 1."
  href="/assets/lab_files/Lab_1.zip"
  icon="right-arrow"
/>
   <LinkCard
      title="Workspace Setup"
      description="If you‚Äôre using a lab computer, you must reconfigure Code Composer Studio each session."
      href="/guides/setupguide/"
      icon="cpu"
   />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the list of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   />
</CardGrid>

---

## Overview

In **Lab 1**, you will extend your embedded system to support **multiple screens**, **sound feedback**, and **modular organization**.  
You will begin with a base project that already includes:

* Two template screens:  
  ‚Äì **Screen 1:** Ambient Light (LUX)  
  ‚Äì **Screen 2:** Microphone (MIC)
* Circular navigation between screens using buttons S1 and S2
* LCD header bar and screen-switching framework

Your goal is to progressively:

1. Add **sound feedback** using PWM.  
2. Split code into **modular source files**.  
3. Add **sensor functionality** for the LUX and MIC screens.

This lab emphasizes **organization** and **incremental design**, rather than building everything at once.

---

<Aside type="caution" title="Lab Requirements">
To complete this lab successfully, you must:
<Steps>
1. Demonstrate **sound feedback** working when pressing S1 and S2.  
2. Organize your code into **separate C/C++ files** (buzzer, lux, microphone).  
3. Implement the **sensor functionality** for each screen.
</Steps>
Each stage will be verified and graded separately.
</Aside>

---

## Learning Objectives

After completing this lab, you will be able to:

* Generate audio tones using **PWM** on the buzzer.
* Implement **multi-screen navigation** with hardware buttons.
* Organize large embedded projects into multiple source files.
* Integrate and visualize sensor data (light and microphone) in real time.
* Understand circular state-machine navigation between screens.

---

## Required Materials

* TI EK-TM4C1294XL LaunchPad  
* BOOSTXL-EDUMKII BoosterPack  
* Micro USB cable for programming and power  
* Code Composer Studio workspace (from Lab 0)

---

## Project Starting Point

You will receive a base project containing:

* `main.cpp` ‚Äî Initializes the LCD, buttons, and navigation logic.  
* Two placeholder screens with basic structure:  
  ‚Äì `ScreenLux_Draw()` and `ScreenMic_Draw()` 
* A functional navigation system that cycles screens in a **circular carousel**.  
  Pressing S1 goes left, S2 goes right.

Initially, the screens show only headers and black backgrounds ‚Äî there is **no sensor functionality** yet.

---

## Part 1 ‚Äî Add Audio Feedback

Your first task is to add **sound feedback** when changing screens.

* Configure the **PWM module** to generate a square-wave tone.
* You may use the reference guide **‚ÄúHow to generate sound with PWM‚Äù** (already available in the course materials).
* Play one short tone when S1 is pressed, and a different tone when S2 is pressed.


**Grading (Step 1 ‚Äì 5 points):**
- PWM configured correctly and audible sound generated.
- Distinct tone for each button.
- No blocking delays that freeze the UI.

<LinkCard
  title="PWM Buzzer Configuration Guide"
  description="Learn how to generate tones using PWM0 on the TM4C1294XL."
  href="/reference/tivaware/pwmsignals/"
  icon="right-arrow"
  target="_blank"
  rel="noopener noreferrer"
/>

---

## üß© Part 2 ‚Äî Organize the Project into Modules

Large embedded projects can quickly become hard to maintain.  
You will now learn how to **split functionality into separate source files**.

### üìÅ Step 2.1 ‚Äî Create `buzzer.cpp`

Move all buzzer-related functions and configuration into a dedicated file:

```text
/src
 ‚îú‚îÄ‚îÄ main.cpp
 ‚îú‚îÄ‚îÄ buzzer.cpp      ‚Üê new file
 ‚îú‚îÄ‚îÄ screen_lux.cpp  ‚Üê to be added next
 ‚îú‚îÄ‚îÄ screen_mic.cpp  ‚Üê to be added next
```

Include:

* `Buzzer_Init()`
* `Buzzer_Beep(freq, duration_ms)`

Then call these functions from `main.cpp`.  
Make sure everything compiles and the sound still works.

**Grading (Step 2.1 ‚Äì 5 points):**
- Buzzer code moved correctly.
- Functions still callable from main.
- No duplicate or missing includes.

---

### üåû Step 2.2 ‚Äî Create `screen_lux.cpp`

Add a new file dedicated to the **ambient light** screen.  
For now, this file only needs:

* `ScreenLux_Init()` ‚Äî empty  
* `ScreenLux_Draw()` ‚Äî clears screen and displays header

Confirm that navigation between screens still works.

---

### üé§ Step 2.3 ‚Äî Create `screen_mic.cpp`

Add another file for the **microphone** screen.  
Include the same placeholder structure:

* `ScreenMic_Init()` ‚Äî empty  
* `ScreenMic_Draw()` ‚Äî clears screen and displays header

**Grading (Step 2.2 & 2.3 ‚Äì 5 points):**
- Code organized into three files (`buzzer`, `lux`, `mic`).
- All screens switch correctly.
- Compilation succeeds without warnings.

---

## üìä Part 3 ‚Äî Add Screen Functionality

Now that your code is modular, you will give meaning to each screen.

### Screen 1 ‚Äî Ambient Light (LUX)

* Initialize and read data from the **OPT3001** light sensor.
* Convert the lux reading to a percentage of a defined maximum (e.g. 1000 lx).
* Display a **horizontal bar** whose length corresponds to brightness.
* Show the numeric lux value on screen.

Example:

```
Ambient Light:  542.6 lx
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
```

---

### Screen 2 ‚Äî Microphone (MIC)

* Configure the **ADC** to read microphone input (PE5 ‚Üí AIN8).
* Calculate a simple average level or RMS amplitude.
* Draw a **vertical bar** that grows with sound intensity.
* Optionally, display approximate dB values.

Example:

```
Microphone Level
|
|‚ñà‚ñà‚ñà
|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
```

**Grading (Step 3 ‚Äì 10 points):**
- Correct sensor initialization and data reading.  
- Bars visually respond to sensor input.  
- Smooth updates without freezing the UI.  

---

## üß† Summary of Graded Steps

| Step | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | Add Sound Feedback | Use PWM buzzer to play tones on S1/S2 press | 5 |
| 2 | Code Organization | Move each module to its own `.cpp` file | 5 |
|   2.1 | Buzzer Module | All buzzer logic separated | 5 |
|   2.2 | Lux Module | Screen 1 structured correctly | 5 |
|   2.3 | Microphone Module | Screen 2 structured correctly | 5 |
| 3 | Screen Functionality | Add bars responding to sensors | 10 |
|    | **Total** |  | **30 points** |

---

## üß≠ Navigation Summary

The navigation logic in `main.cpp` is already implemented:

| Button | Action |
| ------- | ------- |
| **S1** | Go to previous screen |
| **S2** | Go to next screen |
| **Circular Carousel** | After the last screen, loops back to the first |

You can later extend this structure with more screens (e.g., joystick, accelerometer) as future exercises.

---

## ‚úÖ Expected Results

By the end of this lab:

* Pressing S1/S2 plays a tone and changes the screen.  
* The program compiles and runs cleanly with modular files.  
* The **LUX** screen shows a horizontal brightness bar.  
* The **MIC** screen shows a vertical audio-level bar.  
* Code is cleanly organized and easy to expand.

---

## üì¶ Deliverables

Submit the following for evaluation:

1. **CCS project folder** containing all `.cpp` files.  
2. **Demo video** (‚âà 30 s) showing screen navigation and buzzer feedback.  
3. **README.md** explaining your file structure and sensor logic.

---

## üí¨ Instructor Notes

This lab transitions students from single-file prototypes to **modular embedded projects**.  
Emphasize:

* Incremental testing (compile ‚Üí run ‚Üí refactor)
* Avoiding global clutter
* Using clear filenames and consistent naming (e.g. `ScreenX_Init/Draw`)

Students who finish early can add a **third screen (Joystick)** as an optional challenge.

---