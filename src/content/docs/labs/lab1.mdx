---
title: "Lab 1 — Multi-Screen UI and Code Organization"
description: "Learn how to add sound feedback, navigate between screens, and organize modular code."
---
import { Picture } from 'astro:assets';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';


## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 0"
      description="Make sure you finished Lab 0 before starting."
      href="/labs/lab0/"
      icon="setting"
   />
   <LinkCard
  title="Download Lab 1 Template"
  description="Download the starter code for Lab 1."
  href="/assets/lab_files/Lab_1.zip"
  icon="right-arrow"
/>
   <LinkCard
      title="Workspace Setup"
      description="If you’re using a lab computer, you must reconfigure Code Composer Studio each session."
      href="/guides/setupguide/"
      icon="cpu"
   />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the list of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   />
</CardGrid>

---

## Overview

In **Lab 1**, you will extend your embedded system to support **multiple screens**, **sound feedback**, and **modular organization**.  
You will begin with a base project that already includes:

* Two template screens:  
  – **Screen 1:** Ambient Light (LUX)  
  – **Screen 2:** Microphone (MIC)
* Circular navigation between screens using buttons S1 and S2
* LCD header bar and screen-switching framework

Your goal is to progressively:

1. Add **sound feedback** using PWM.  
2. Split code into **modular source files**.  
3. Add **sensor functionality** for the LUX and MIC screens.

This lab emphasizes **organization** and **incremental design**, rather than building everything at once.

---

<Aside type="caution" title="Lab Requirements">
To complete this lab successfully, you must:
<Steps>
1. Demonstrate **sound feedback** working when pressing S1 and S2.  
2. Organize your code into **separate C/C++ files** (buzzer, lux, microphone).  
3. Implement the **sensor functionality** for each screen.
</Steps>
Each stage will be verified and graded separately.
</Aside>

---

## Learning Objectives

After completing this lab, you will be able to:

* Generate audio tones using **PWM** on the buzzer.
* Implement **multi-screen navigation** with hardware buttons.
* Organize large embedded projects into multiple source files.
* Integrate and visualize sensor data (light and microphone) in real time.
* Understand circular state-machine navigation between screens.

---

## Required Materials

* TI EK-TM4C1294XL LaunchPad  
* BOOSTXL-EDUMKII BoosterPack  
* Micro USB cable for programming and power  
* Code Composer Studio workspace (from Lab 0)

---

## Project Starting Point

You will receive a base project containing:

* `main.cpp` — Initializes the LCD, buttons, and navigation logic.  
* Two placeholder screens with basic structure:  
  – `ScreenLux_Draw()` and `ScreenMic_Draw()` 
* A functional navigation system that cycles screens in a **circular carousel**.  
  Pressing S1 goes left, S2 goes right.

Initially, the screens show only headers and black backgrounds — there is **no sensor functionality** yet.

---

## Part 1 — Add Audio Feedback

Your first task is to add **sound feedback** when changing screens.

* Configure the **PWM module** to generate a square-wave tone.
* You may use the reference guide **“How to generate sound with PWM”** (already available in the course materials).
* Play one short tone when S1 is pressed, and a different tone when S2 is pressed.


**Grading (Step 1 – 5 points):**
- PWM configured correctly and audible sound generated.
- Distinct tone for each button.
- No blocking delays that freeze the UI.

<LinkCard
  title="PWM Buzzer Configuration Guide"
  description="Learn how to generate tones using PWM0 on the TM4C1294XL."
  href="/reference/tivaware/pwmsignals/"
  icon="right-arrow"
  target="_blank"
  rel="noopener noreferrer"
/>

---

## Part 2 — Organize the Project into Modules

Large embedded projects can quickly become hard to maintain.  
You will now learn how to **split functionality into separate source files**.
To create new source files in Code Composer Studio:
1. Right-click on the project folder in the **Project Explorer**.
2. Select **New > Source File**.

<p align="center">
  <img src="/assets/images/new_source_file.png" alt="How to create a new source file in Code Composer Studio" width="500"/>
    <br />
  <sub><span style="color:#4ec9b0; font-weight:bold;"> How to create a new source file in Code Composer Studio</span></sub>
</p>

### Step 2.1 — Create `buzzer.cpp`

Move all buzzer-related functions and configuration into a dedicated file:

```text
/src
 ├── main.cpp
 ├── buzzer.cpp      ← new file
```

Include:

* `Buzzer_Init()`
* `Buzzer_Beep(freq, duration_ms)`

Then call these functions from `main.cpp`.  
Make sure everything compiles and the sound still works.

Here is an example structure for `buzzer.cpp`:

```cpp
//All buzzer-dependent includes
#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "driverlib/pwm.h"
#include "driverlib/pin_map.h"

// Buzzer configuration and functions
#define BUZZER_PWM_BASE    PWM0_BASE
#define BUZZER_GEN         PWM_GEN_0
#define BUZZER_OUTNUM      PWM_OUT_1
#define BUZZER_OUTBIT      PWM_OUT_1_BIT

//Variables externally defined
extern uint32_t gSysClk; // defined in main.cpp


void Buzzer_Init(void)
{
      //Buzzer initialization code
}

// ---------------------------------------------------------------------------
// Generates a beep with frequency and duration
// ---------------------------------------------------------------------------
void Buzzer_Beep(uint32_t freq_hz, uint32_t duration_ms)
{
      //Buzzer beep code   
}

```

and in `main.cpp`, include the buzzer header and call the functions:

```cpp
// include as extern the buzzer functions needed
extern void Buzzer_Init(void);
extern void Buzzer_Beep(uint32_t, uint32_t);

// In main(), initialize the buzzer
int main(void)
{
    // Other initializations...  
    Buzzer_Init();
      while (1)
      {
         ...
      }
}

// When S1 or S2 is pressed, call Buzzer_Beep() with appropriate parameters
void onS1Press()
{
    Buzzer_Beep(440, 100); // Example: A4 note for 100 ms
}
...
```
<Aside type="tip"> 
Remember to remove the old buzzer functions definitions from main.cpp after moving them.
</Aside>

**Grading (Step 2.1 – 5 points):**
- Buzzer code moved correctly.
- Functions still callable from main.
- No duplicate or missing includes.

---

### Step 2.2 — Create `screen_lux.cpp`

```text
/src
 ├── main.cpp
 ├── buzzer.cpp 
 ├── screen_lux.cpp  ← to be added next
```

Add a new file dedicated to the **ambient light** screen.  
For now, this file only needs:

* `ScreenLux_Init()` — empty  
* `ScreenLux_Draw()` — clears screen and displays header
* `DrawBar()` - draws horizontal bar based on lux value

Your screen_lux.cpp might look like this:

```cpp
//Include dependencies
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "grlib/grlib.h"
#include "Crystalfontz128x128_ST7735.h"
#include "OPT3001.h"

// ============================================================================
// External references Used for drawing
// ============================================================================
// These symbols are defined in main.cpp and shared across all screens.
extern tContext gContext;  // Global graphics context (LCD drawing object)
extern bool btnLeft_isPressed();
extern bool btnRight_isPressed();
extern void DrawHeader(const char *title, bool leftActive, bool rightActive);

// ============================================================================
// Global variable (local to this file)
// ============================================================================
static float luxValue = 0.0f;  // Stores the most recent lux reading

// ============================================================================
// ScreenLux_Init()
// ============================================================================
// Initializes the OPT3001 ambient light sensor.
// This function is called once at startup (from main.cpp).
// ============================================================================
void ScreenLux_Init(void)
{
    // Sensor initialization code here
}

// ============================================================================
// ScreenLux_Draw()
// ============================================================================
void ScreenLux_Draw(void)
{
   // Drawing code here
}
```

Your main.cpp should include the new header and call the functions:


```cpp
//Include as extern the lux screen functions needed in main.cpp
extern void ScreenLux_Init(void);
extern void ScreenLux_Draw(void);

void main(void)
{
    // Other initializations...
    ScreenLux_Init();
    while (1)
    {
        // Call ScreenLux_Draw() when the lux screen is active every 50 ms
        ScreenLux_Draw();
    }
}
```

Confirm that navigation between screens still works as template with no functionality yet.

---

### Step 2.3 — Create `screen_mic.cpp`
```text
/src
 ├── main.cpp
 ├── buzzer.cpp 
 ├── screen_lux.cpp
 ├── screen_mic.cpp  ← to be added next
```
Add another file for the **microphone** screen.  
Include the same placeholder structure:

* `ScreenMic_Init()` — empty  
* `ScreenMic_Draw()` — clears screen and displays header
* `DrawBar()` - draws vertical bar based on mic level

Your screen_mic.cpp might look like this:

```cpp

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <math.h>
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "driverlib/adc.h"
#include "driverlib/gpio.h"
#include "grlib/grlib.h"
#include "Crystalfontz128x128_ST7735.h"

// ============================================================================
// External references (shared from main.cpp)
// ============================================================================
extern tContext gContext;
extern bool btnLeft_isPressed();
extern bool btnRight_isPressed();
extern void DrawHeader(const char *title, bool leftActive, bool rightActive);

// ============================================================================
// Microphone input configuration
// ----------------------------------------------------------------------------
// The microphone output on the BoosterPack MKII is connected to PE5  AIN8.
// We use ADC0, Sample Sequencer 3 (single channel, manual trigger).
// ============================================================================
#define MIC_ADC_BASE      ADC0_BASE
#define MIC_ADC_SEQ       3
#define MIC_ADC_CHANNEL   ADC_CTL_CH8


static void Mic_Init(void)
{
   
}

static uint16_t Mic_Read(void)
{
      return 0;
}


static float Mic_Level(void)
{
      return 0.0f;
}

// ============================================================================
// ScreenMic_Init()
// ============================================================================
// Called once at program start. Initializes the ADC channel for the microphone.
// ============================================================================
void ScreenMic_Init(void)
{
    Mic_Init();
}

// ============================================================================
// ScreenMic_Draw()
// ============================================================================
// Called periodically from main.cpp (every ~50 ms).
// Reads microphone level and updates the bar meter on screen.
//
// Visualization:
//   - Green = low volume
//   - Yellow = medium volume
//   - Red = high volume
// ============================================================================
void ScreenMic_Draw(void)
{
}
```
**Grading (Step 2.2 & 2.3 – 5 points):**
- Code organized into three files (`buzzer`, `lux`, `mic`).
- All screens switch correctly.
- Compilation succeeds without warnings.
- No functionality yet; just placeholders.
---

## Part 3 — Add Screen Functionality

Now that your code is modular, you will give meaning to each screen.

### Screen 1 — Ambient Light (LUX)

* Initialize and read data from the **OPT3001** light sensor.
* Convert the lux reading to a percentage of a defined maximum (e.g. 1000 lx).
* Display a **horizontal bar** whose length corresponds to brightness.
* Show the numeric lux value on screen.

Example:

```
Ambient Light:  85.6 lx
[████████████░░░░░░░░░░░░░░░░]
```
<LinkCard
  title="LUX Sensor Integration Guide"
  description="How to interface with the OPT3001 ambient light sensor using I2C."
  href="/reference/libraries/otp3001/"
  icon="right-arrow"
  target="_blank"
  rel="noopener noreferrer"
/>
---

### Screen 2 — Microphone (MIC)

* Configure the **ADC** to read microphone input (PE5 → AIN8).
* Calculate a simple average level or RMS amplitude.
* Draw a **vertical bar** that grows with sound intensity.

Example:

```
Microphone Level
| |
|█|
|█|
|█|
```

<LinkCard
   title="MIC Sensor Integration Guide"
   description="How to interface with the microphone using the ADC on the TM4C1294XL."
   href="/reference/tivaware/mic_adc/"
   icon="right-arrow"
   target="_blank"
   rel="noopener noreferrer"
/>

**Grading (Step 3 – 10 points):**
- Correct sensor initialization and data reading.  
- Bars visually respond to sensor input.  
- Smooth updates without freezing the UI.  

---
## Part 4 - Additional Screens 
You will now add two more screens to the project:
- **Joystick Screen** — Display the real-time position of the joystick inside a circular region.
- **Accelerometer Ball Screen** — Simulate a bouncing ball affected by gravity from the accelerometer readings.

Both screens will use the same structure as in previous screens, with their own initialization (`_Init`) and drawing (`_Draw`) functions.

## 🕹️ Joystick Screen

The joystick outputs two analog voltages (X and Y axes) that are read using the **ADC**. The goal is to represent the joystick’s position as a moving dot inside a circular zone.

### Features
- A **white circle** defines the joystick’s movement boundary.
- A **cyan dot** shows the current position.
- **X/Y numeric values** are displayed below.

### Implementation Example

```c
void ScreenJoystick_Init(void)
{
    js.begin();             // Initialize joystick ADC inputs
    js.calibrateCenter(32); // Calibrate to remove offset
}

void ScreenJoystick_Draw(void)
{
    js.tick();
    float joyX = js.x();  // −1.0 → +1.0
    float joyY = js.y();  // −1.0 → +1.0

    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);

    DrawHeader("Joystick", btnLeft_isPressed(), btnRight_isPressed());

    int cx = 64, cy = 75, radius = 40;
    GrContextForegroundSet(&gContext, ClrWhite);
    GrCircleDraw(&gContext, cx, cy, radius);

    int px = cx + (int)(joyX * radius);
    int py = cy - (int)(joyY * radius);
    GrContextForegroundSet(&gContext, ClrCyan);
    GrCircleFill(&gContext, px, py, 3);

    char buf[32];
    snprintf(buf, sizeof(buf), "X=%.2f  Y=%.2f", joyX, joyY);
    GrContextForegroundSet(&gContext, ClrYellow);
    GrStringDrawCentered(&gContext, buf, -1, 64, 115, false);

    GrFlush(&gContext);
}
```

<Aside type="tip" title="Coordinate System">
The joystick values are normalized between **−1.0 and +1.0**. The center of the circle (0,0) corresponds to the joystick in its neutral position.
</Aside>

---

## ⚽ Accelerometer Ball Screen

This visualization treats the accelerometer’s X/Y readings as a **gravity vector**. When the board is tilted, the virtual ball accelerates and bounces around the screen.

### Features
- Reads **accelerometer X and Y axes**.
- Simulates **gravity, friction, and bounce**.
- The **yellow ball** moves and rebounds inside the LCD boundaries.

### Implementation Example

```c
static float posX = 0, posY = 0, velX = 0, velY = 0;

void ScreenAccel_Init(void)
{
    Accel_Init();
    posX = rand() % 128;
    posY = 25 + rand() % 100;
    velX = velY = 0.0f;
}

void ScreenAccel_Draw(void)
{
    float ax, ay;
    Accel_Read(&ax, &ay);

    velX += ax * 0.9f;
    velY += -ay * 0.9f;

    posX += velX;
    posY += velY;

    if (posX < 5)   { posX = 5;   velX *= -0.8f; }
    if (posX > 122) { posX = 122; velX *= -0.8f; }
    if (posY < 25)  { posY = 25;  velY *= -0.8f; }
    if (posY > 122) { posY = 122; velY *= -0.8f; }

    velX *= 0.99f;
    velY *= 0.99f;

    tRectangle bg = {0, 21, 127, 127};
    GrContextForegroundSet(&gContext, ClrBlack);
    GrRectFill(&gContext, &bg);

    DrawHeader("Accelerometer Ball", btnLeft_isPressed(), btnRight_isPressed());

    GrContextForegroundSet(&gContext, ClrYellow);
    GrCircleFill(&gContext, (int)posX, (int)posY, 5);
    GrFlush(&gContext);
}
```

<Aside type="note" title="Physics Parameters">
- **Gravity strength:** 0.9f multiplier controls how sensitive the motion is to tilt.  
- **Friction:** 0.99f reduces velocity slightly each frame.  
- **Bounce factor:** −0.8f simulates energy loss on collisions.
</Aside>

---

## 🧩 Integration Tip

To integrate these screens into your main program:

```c
switch (currentScreen) {
  case SCREEN_JOYSTICK:
    ScreenJoystick_Draw();
    break;
  case SCREEN_ACCEL:
    ScreenAccel_Draw();
    break;
}
```

Each screen should be updated approximately **20–50 times per second** (every 20–50 ms) for smooth animation.

---


## 🧠 Summary of Graded Steps

| Step | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | Add Sound Feedback | Use PWM buzzer to play tones on S1/S2 press | 5 |
| 2 | Code Organization | Move each module to its own `.cpp` file | 5 |
|   2.1 | Buzzer Module | All buzzer logic separated | 5 |
|   2.2 | Lux Module | Screen 1 structured correctly | 5 |
|   2.3 | Microphone Module | Screen 2 structured correctly | 5 |
| 3 | Screen Functionality | Add bars responding to sensors | 10 |
|    | **Total** |  | **30 points** |

---

## 🧭 Navigation Summary

The navigation logic in `main.cpp` is already implemented:

| Button | Action |
| ------- | ------- |
| **S1** | Go to previous screen |
| **S2** | Go to next screen |
| **Circular Carousel** | After the last screen, loops back to the first |

You can later extend this structure with more screens (e.g., joystick, accelerometer) as future exercises.

---

## ✅ Expected Results

By the end of this lab:

* Pressing S1/S2 plays a tone and changes the screen.  
* The program compiles and runs cleanly with modular files.  
* The **LUX** screen shows a horizontal brightness bar.  
* The **MIC** screen shows a vertical audio-level bar.  
* Code is cleanly organized and easy to expand.

---

## 📦 Deliverables

Submit the following for evaluation:

1. **CCS project folder** containing all `.cpp` files.  
2. **Demo video** (≈ 30 s) showing screen navigation and buzzer feedback.  
3. **README.md** explaining your file structure and sensor logic.

---

## 💬 Instructor Notes

This lab transitions students from single-file prototypes to **modular embedded projects**.  
Emphasize:

* Incremental testing (compile → run → refactor)
* Avoiding global clutter
* Using clear filenames and consistent naming (e.g. `ScreenX_Init/Draw`)

Students who finish early can add a **third screen (Joystick)** as an optional challenge.

---