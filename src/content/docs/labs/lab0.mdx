---
title: "Lab 0: Tutorial, Button Handling, Stopwatch"
description: Introductory tutorial to embedded system platform and development environment
links:
- /guides/setupguide/
- /guides/labtimeline/
---

import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';
import { Card, CardGrid, Badge, LinkCard } from '@astrojs/starlight/components';
import { FileTree } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Setup Guide First"
      description="Before starting Lab 0, make sure you have completed the environment setup."
      href="/guides/setupguide/"
      icon="setting"
   />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the overview of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   />
<LinkCard
  title="Download Lab 0 Template"
  description="Download the starter code for Lab 0."
  href="/assets/lab_files/Lab_0.zip"
  icon="right-arrow"
/>
</CardGrid>

## Introduction

<Aside type="note" title="Purpose">
This lab serves as an introductory tutorial to the **embedded system platform** and **software development environment** that will be used throughout this course. It also provides a review of key concepts from **ECE3849**, helping you become familiar with both the hardware and software tools that will be used in subsequent labs.
</Aside>

In this lab, you will:
- Set up your development environment using **Code Composer Studio (CCS)**
- Explore the **TM4C1294XL LaunchPad** and **BOOSTXL-EDUMKII BoosterPack** hardware
- Import and run a **starter stopwatch project** to verify your environment setup
- Learn how to write modular embedded programs using **C/C++** and **TI's driver libraries**

<Aside type="caution" title="Lab Requirements"></Aside>
To complete each lab in this course, you must:
<Steps>

1. **Submit your source code** for the lab
2. **Demonstrate your project** in operation to one of the course staff (TA or tutor)  
3. Receive a **sign-off** after successful demonstration
</Steps>

You will be graded based on the completion of the required steps and correct functionality.  
Late submissions will receive a **20% penalty** unless otherwise specified by your instructor.

### <span style="display: inline-flex; align-items: center;"><Icon name="document" />  Grading Rubric</span>
| Step | Description | Max Points | Score |
|:-----|:-------------|:-----------:|:------:|
| 1 | Compile and flash the **starter stopwatch example** (verify environment) | 10 |   |
| 2 | Extend the stopwatch to display **HH:MM:SS:MS** format | 20 |   |
| 3 | Implement physical buttons **S1 → Play/Pause** and **S2 → Reset** | 35 |   |
| 4 | Add on-screen buttons with feedback and state text (**Running / Stopped**) | 15 |   |
| 5 | **Source Code** — Organization, readability, and modular structure | 20 |   |
|   | **Total** | **100** |   |

## Objectives

By the end of this lab, you will have accomplished:

* Install software: **Code Composer Studio (CCS)** and **Free-RTOS**
* Set up a CCS project for the EK‑TM4C1294XL + BoosterPack
* Output to the 128×128 LCD display
* Configure general purpose timers and interrupts
* Read and debounce user buttons
* Understand how to import libraries

### Key Learning Points

- Using **hardware timers** for precise time measurement.  
- Managing non‑blocking tasks with `elapsedMillis` utilities.  
- Handling **button debouncing** and event callbacks.  
- Creating simple GUIs using **GRLIB primitives**.  
- Synchronizing display updates with real‑time processes.

## Required Materials

Before starting this lab, make sure you have the following:

- **TI EK-TM4C1294XL LaunchPad** Development Kit  
- **BOOSTXL-EDUMKII** BoosterPack  
- **Micro-USB cable** for programming and power  
- **Lab 0 Template:** <a href="https://drive.google.com/file/d/1FJGgkUAV4Qfg2_SORUwcWuvAiNmf_0bi/view?usp=sharing" target="_blank" rel="noopener noreferrer">Download ZIP</a>


## Stopwatch Implementation

Implement a stopwatch with hours, minutes, seconds, and milliseconds, using the **S1** button for Play/Pause and **S2** for Reset. The application must also show two on‑screen buttons that react to physical button interactions, as well as a text label indicating the current state: **Running** or **Stopped**.

### Overview

In this lab exercise, you will use a **modular C/C++ approach** to design a stopwatch running on the **TM4C1294XL LaunchPad** with the **BOOSTXL‑EDUMKII LCD**.  
The system measures elapsed time using hardware timers and updates the display at a fixed refresh rate.

The application demonstrates:
- Use of **timers** for precise millisecond tracking.
- Integration of **physical button input** with graphical feedback.
- Modular code structure using custom libraries (`button.h`, `timerLib.h`, `elapsedTime.h`).
- Real‑time display management with **TI GRLIB**.

---

### Starter Example
> [!TIP]First test
> Compile the provided example and flash it to the LaunchPad.This will let you verify that your environment, drivers, and libraries are correctly configured before starting your own modifications.

You are provided with a simplified starter example that demonstrates how to:
- Initialize the system clock and LCD display.
- Configure a periodic hardware timer using the `Timer` class and `elapsedTime` Class.
- Use the `Button` class to detect **press** and **release** events for S1.
- Draw on‑screen UI elements such as rectangles and text using GRLIB.

In the provided code:
- **S1** toggles between **Play** and **Pause**.
- A single on‑screen button labeled **PLAY/PAUSE** changes color when pressed.
- The display shows the word **STOPWATCH** and a time counter (in seconds) at the center.
- The background is cleared and redrawn periodically at 20 ms button scan and 50 ms display refresh intervals.


### Understanding the Code Structure

> [!Note]
> Learn how the provided stopwatch code is structured and understand which components are essential in every embedded project you will develop in this course.

---

### 1. System Initialization

Every embedded program should start by **disabling global interrupts** and enabling the **Floating-Point Unit (FPU)**. The FPU improves performance when using floating-point arithmetic, which is often needed for signal processing, filters, or calculations involving time.

```cpp
IntMasterDisable();
FPUEnable();
FPULazyStackingEnable();
```

Afterward, it is crucial to **configure the system clock**, as all peripherals (timers, ADC, UART, etc.) depend on it to operate correctly:

```cpp
gSystemClock = SysCtlClockFreqSet(
    SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN |
    SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480,
    120000000);
```

This setup uses the **25 MHz external crystal** and the **PLL** (Phase-Locked Loop) to generate a **120 MHz system clock**.

---

### 2. Display Initialization

If the program uses the LCD, the display must be initialized through the graphics context `tContext`. This block configures the SPI interface and prepares the screen for drawing.

```cpp
tContext sContext;
initializeDisplay(sContext);
```

The display is connected through **SPI2**, and this helper function configures the GRLIB driver and clears the screen:

```cpp
static void initializeDisplay(tContext &context)
{
    Crystalfontz128x128_Init();
    Crystalfontz128x128_SetOrientation(LCD_ORIENTATION_UP);
    GrContextInit(&context, &g_sCrystalfontz128x128);
    GrContextFontSet(&context, &g_sFontFixed6x8);

    tRectangle full = {0, 0, 127, 127};
    GrContextForegroundSet(&context, ClrBlack);
    GrRectFill(&context, &full);
}
```

> [!TIP]
> Always include this display initialization block whenever your project uses the **Crystalfontz 128×128 LCD**.

---

### 3. Timer and Elapsed Time Setup
Any task that needs to be executed periodically—like reading a sensor, blinking an LED, or updating the display—requires a timer. In this project, **Timer0** is used as the reference for the `elapsedMillis` objects:

```cpp
Timer timer;
configureTimer(timer);

elapsedMillis buttonTick(timer);
elapsedMillis displayTick(timer);
elapsedMillis stopwatchTick(timer);
```

Each `elapsedMillis` instance keeps track of elapsed time independently, allowing you to execute tasks at precise intervals without using delays.

The timer configuration function:

```cpp
static void configureTimer(Timer &timer)
{
    timer.begin(gSystemClock, TIMER0_BASE);
}
```

This initializes **Timer0** as a system time base synchronized with the configured system clock.

---

### Button Configuration

Each hardware button (S1, S2, or others) must be configured using the `Button` class before it can be used. The button library handles debouncing and state detection automatically.

```cpp
static void setupButtons()
{
    btnPlayPause.begin();
    btnPlayPause.setTickIntervalMs(BUTTON_TICK_MS);
    btnPlayPause.setDebounceMs(30);
}
```

> [!NOTE]
> The library automatically assigns the correct GPIO pins for S1 and S2 based on the LaunchPad hardware mapping.

After setup, interrupts can be re-enabled:

```cpp
IntMasterEnable();
```

---

### 5. Main Loop Structure

The main loop (`while(true)`) is where all recurring tasks are executed in non-blocking intervals. Each task checks its elapsed time counter and executes only when its timer expires.

This pattern ensures that the program remains responsive without delays.

---

### 6. Display Drawing Functions

It’s recommended to separate the LCD drawing logic into functions for readability and maintainability:

#### Stopwatch Display
Draws the stopwatch title and current time.
```cpp
static void drawStopwatchScreen(tContext &context, uint32_t currentSec, bool running)
{
    tRectangle rectFull = {0, 0, 127, 127};
    GrContextForegroundSet(&context, ClrBlack);
    GrRectFill(&context, &rectFull);

    GrContextForegroundSet(&context, ClrCyan);
    GrStringDrawCentered(&context, "STOPWATCH", -1, 64, 15, false);

    char str[10];
    snprintf(str, sizeof(str), "%02u s", currentSec);

    GrContextForegroundSet(&context, running ? ClrYellow : ClrOlive);
    GrStringDrawCentered(&context, str, -1, 64, 50, false);
}
```

#### Button Drawing
Handles rendering of buttons with color changes when pressed.
```cpp
static void drawButton(tContext &context, const MyButton &btn)
{
    uint16_t bgColor = btn.pressed ? ClrBlack : ClrGray;
    uint16_t textColor = btn.pressed ? ClrWhite : ClrBlack;

    tRectangle rect = {btn.x, btn.y, btn.x + btn.w - 1, btn.y + btn.h - 1};
    GrContextForegroundSet(&context, bgColor);
    GrRectFill(&context, &rect);

    GrContextForegroundSet(&context, ClrBlack);
    GrRectDraw(&context, &rect);

    GrContextForegroundSet(&context, textColor);
    GrStringDrawCentered(&context, btn.label, -1,
                         btn.x + btn.w / 2, btn.y + btn.h / 2, false);
}
```

> [!TIP]
> Separate the drawing logic for UI elements (like stopwatch text and buttons) from the logic that updates values and handles input events. This makes your code modular, cleaner, and easier to debug.

## Implementation Tasks

You must extend this implementation to complete the full stopwatch behavior:

1. **Add a second button (S2)**  
   ‑ Use `Button btnReset(S2);`  
   ‑ When pressed, set the stopwatch time back to zero.

2. **Expand the time format**  
   ‑ Display the time as `HH:MM:SS:MS`.  
   ‑ Convert milliseconds using division and modulo operations.

3. **Display the system state**  
   ‑ Show a label `Running` or `Stopped` depending on the value of `gRunning`.

4. **Add a second on‑screen button for Reset**  
   ‑ Create a new `MyButton` struct instance for Reset.  
   ‑ The button should visually change when S2 is pressed.

5. **Improve display logic**  
   ‑ Limit updates to roughly 60 Hz (`~16 ms` between redraws).  
   ‑ Only refresh when time, button state, or mode changes.

6. **Ensure debouncing and callbacks**  
   ‑ Use `btnPlayPause.setDebounceMs(30)` and similar for the Reset button.  
   ‑ Implement callback functions `onPlayPauseClick()`, `onResetClick()`, etc.

---

### Expected Behavior

- The stopwatch starts in the **Stopped** state at `00:00:00:000`.  
- Pressing **S1** toggles between **Running** and **Stopped**.  
- Pressing **S2** resets the timer to zero.  
- The text label reflects the current state.
- The on‑screen buttons change color briefly when their physical counterparts are pressed.

<p align="center">
  <img src="https://hackmd.io/_uploads/rknEKi4Rlx.png" alt="Stopwatch example screen" width="420" style="border-radius:10px; box-shadow:0 0 10px #00ffff66;"/>
  <br/>
  <sub><span style="color:#4ec9b0; font-weight:bold;">Example of the stopwatch interface with on‑screen buttons and state indicator</span></sub>
</p>


## Deliverables

Your final stopwatch application must:
- Display the time in `HH:MM:SS:MS` format.  
- Show `Running` or `Stopped` based on the system state.  
- Respond visually and functionally to both S1 and S2 presses.  
- Maintain smooth updates and clean modular code.

---

### Submitting Source Code

**Exporting project:**

1. Ensure project named `ece3849_lab0_<username>`.
2. Right‑click the project → `Export...` → `General` → `Archive File`.
3. Choose the output path and filename equal to the project name (`ece3849_lab0_<username>.zip`).
4. Upload `.zip` to Canvas.

---

## Appendix / Useful Links

* TI TivaWare: [https://www.ti.com/tool/SW-TM4C](https://www.ti.com/tool/SW-TM4C)
* Graphics Library User Guide: [https://www.ti.com/lit/ug/spmu300e/spmu300e.pdf](https://www.ti.com/lit/ug/spmu300e/spmu300e.pdf)
* TM4C1294 Datasheet: [https://www.ti.com/lit/ds/symlink/tm4c1294ncpdt.pdf](https://www.ti.com/lit/ds/symlink/tm4c1294ncpdt.pdf)
* EK‑TM4C1294XL: [https://www.ti.com/tool/EK-TM4C1294XL](https://www.ti.com/tool/EK-TM4C1294XL)
* BoosterPack EDUMKII: [https://www.ti.com/tool/BOOSTXL-EDUMKII](https://www.ti.com/tool/BOOSTXL-EDUMKII)

---