---
title: "Lab 3: Snake Game Part 1"
description: "In this lab, you will design a simple Snake game using FreeRTOS on the TM4C1294XL LaunchPad. The focus is on modular task design and correct mutex usage for shared resources."
links:
- /labs/lab2/
- /guides/labtimeline/
- /guides/FreeRTOS/freertos/
tags:
  - freertos
---
import { Picture } from 'astro:assets';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';
import { Icon } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';


## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 2"
      description="Make sure you finished Lab 2 before starting."
      href="/labs/lab2/"
      icon="setting"
   />
   <LinkCard
       title="Download Lab 3 Starter Code"
       description="Just the suggested files not the project."
       href="/assets/lab_files/snake_base_lab3.zip"
       icon="right-arrow"
    />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the list of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   /> 
</CardGrid>
---

## Objective
In this lab, you will extend your FreeRTOS skills by designing a simple **Snake game** on the TM4C1294XL LaunchPad. The focus is on **modularity**, **task design**, and correct **mutex usage** for shared resources.

---

## Learning Goals

- Organize a real-time application into modular tasks.
- Use a **mutex** to protect shared resources (LCD and game state).
- Understand task synchronization and timing under FreeRTOS.
- Practice modular programming with separate source files.

---

## System Overview

Your project will follow the same modular architecture used in previous labs. The `main.cpp` file will handle **initialization** and **task creation**, while other modules will encapsulate specific functionalities.

## Grading Rubric

| Step | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | Run Snake Base | Build and run the provided Snake starter project; verify tasks run and basic frame displays | 8 |
| 2 | LCD Mutex Protection | Guard all LCD drawing with a FreeRTOS mutex; avoid blocking while the mutex is held | 12 |
| 3 | Buzzer via Queue + Buttons | Implement a buzzer task with a queue in `buzzer.h/.cpp`; Play/Pause button events trigger a short tone | 12 |
| 4 | Random Fruit Spawn | Place fruit at random grid locations; avoid spawning on the snake body | 8 |
| 5 | Score + Fruit Respawn | When head reaches fruit: increment score, remove fruit, spawn a new one; update UI | 12 |
| 6 | Eat Feedback Sound | Play an audible feedback tone when the fruit is eaten | 8 |
| 7 | Movement Rules + Self-Collision | Disallow instant reverse direction; detect self-collision and handle game over/pause/reset | 15 |
|   | Lab report | Written lab report (see Canvas guidelines) | 25 |
|   | **Total** |  | **100 points** |

## Expected Results

By the end of this lab:

- The Snake base project builds and runs without faults, showing the basic game frame.
- All LCD drawing is protected with a FreeRTOS mutex; no blocking delays occur while holding the mutex.
- A buzzer task consumes a queue; Play/Pause button events produce an audible click/beep.
- Fruit appears at random grid positions and never overlaps the snake body.
- Score increases by 1 when the snake's head reaches the fruit; the fruit despawns and a new one appears; the UI reflects the score.
- Eating a fruit triggers a short feedback sound.
- The snake cannot reverse direction immediately; self-collisions are detected and handled appropriately (game over/pause/reset).
- The render task updates periodically without blocking; timing is driven by tasks/timers.
- The codebase is modular with `buzzer.{h,cpp}`, `display.*`, `game.*`, `main.cpp`, and a shared objects header.


## First Steps

<Steps>
<ol>
    <li>
        Create a new CCS project with FreeRTOS support, similar to Lab 2.

        <LinkCard
            title="FreeRTOS Project Setup"
            description="Checklist to add FreeRTOS to your CCS project."
            href="/guides/freertos/freertosproyects/"
            icon="right-arrow"
            target="_blank"
            rel="noopener noreferrer"
        />
    </li>

    <li>
        Add the required library files and import any external libraries required by the starter.

        <LinkCard
             title="Download Libraries"
             description="Download libraries needed for the lab."
             href="/assets/libraries/libraries.zip"
             icon="right-arrow"
        />
        <LinkCard
             title="Importing External Libraries"
             description="Instructions for importing external libraries into your project."
             href="/guides/ccs/external_libraries/"
             icon="right-arrow"
        />
    </li>

    <li>
        Copy the provided starter code into your project. (Drag and drop the files from the unzipped folder into your CCS project.)

        Starter structure after copying (this is the starter's file list, not the full CCS project tree):

        ```
        <starter>/
        ├─ app_objects.h
        ├─ display.cpp
        ├─ display.h
        ├─ game.cpp
        ├─ game.h
        └─ main.cpp
        ```
    </li>

    <li>
        Build and run the project to verify that it compiles correctly and the FreeRTOS scheduler starts. You should see the snake with a green head and yellow body moving on the screen, and you can control it with the joystick.
        This example does not yet implement the full game features, only the basic snake movement.
    </li>
</ol>
</Steps>

---


## Mutex — What and Why

A **mutex (mutual exclusion)** is a synchronization primitive used to prevent multiple tasks from accessing a shared resource simultaneously.

In this lab, the **LCD display** is a shared resource. To prevent concurrent access (which may corrupt the screen or SPI communication), you must wrap drawing operations with a **mutex lock**.

### Example Concept

```c
xSemaphoreTake(xMutexLCD, portMAX_DELAY);
// Critical section: LCD drawing
DrawGrid();
xSemaphoreGive(xMutexLCD);
```

<Aside type="tip">
   Only one task should draw on the display at a time. Other tasks must wait until the mutex is released.
</Aside>

### Guidelines
- Keep the mutex **locked only while drawing**.
- Never use `vTaskDelay()` while holding the mutex.
- Avoid using mutexes in interrupt context.

---

## FreeRTOS Components Used

| Primitive | Purpose |
|------------|----------|
| **Task** | Separate functionality (input, snake update, render). |
| **Queue** | Used in `buzzer.cpp` to send tone events to the buzzer task. |
| **Mutex** | Protects LCD operations from concurrent access. |

---

## Implementation Steps
### 1. Create the following files:
We recommend the following file structure for your Snake game project. You can organize it differently, but this is a solid starting point:

| File | Purpose |
|------|----------|
| **buzzer.h / buzzer.cpp** | PWM buzzer driver with background task and queue for sound events. |
| **display.h / display.cpp** | LCD initialization and drawing (snake, fruit, score). |
| **game.h / game.cpp** | Core game logic: snake position, fruit, collision detection. |
| **app_objects.h** | Shared handles and global objects (LCD context, clock, mutex). |
| **main.cpp** | System setup, creation of mutex and tasks, and scheduler start. |


For every `.cpp` file except `main.cpp`, create and include its corresponding header file (`.h`). The header file should declare the functions and any shared types or constants that the module provides. This allows other source files to use those functions by including the header, without needing to know their implementation details.

For example, for `buzzer.cpp`, declare the buzzer functions in `buzzer.h`:

```c
#pragma once

#include <stdint.h>

void Buzzer_Init(void);
void buzzer_post(uint32_t freq, uint32_t ms);
//other buzzer-related declarations
//...
//...
//..
//.
```
<Aside type="note">
   Add <code>#pragma once</code> to every header file to prevent redefinitions.
</Aside>

and implement the functions in `buzzer.cpp`:

```c
#include "buzzer.h"
void Buzzer_Init(void) {
    // Buzzer initialization code
}
void buzzer_post(uint32_t freq, uint32_t ms) {
    // Code to post a tone to the buzzer task
}
// Other buzzer-related implementations
// ...
// ...
```
Finally, include `buzzer.h` in any other source file that needs to use the buzzer functions:

```c
#include "buzzer.h"
void example() {
    Buzzer_Init();
    buzzer_post(440, 500); // Play A4 for 500 ms
}
```   

For `app_objects.h` we recommend the following content:

<Aside type="tip"  title='Why?'>
This header declares shared global objects like the LCD context and mutex. Some of these objects are used across multiple modules, so declaring them here avoids tight coupling and circular dependencies.
</Aside>

```c
// Shared application-level objects used across modules.
// Keep this header minimal to avoid tight coupling.

#pragma once

extern "C" {
#include "FreeRTOS.h"
#include "semphr.h"
#include "grlib/grlib.h"
}

// Global graphics context for the LCD driver
extern tContext gContext;

// System clock frequency (Hz) set during startup
// Use stdint types to match TivaWare APIs
#include <stdint.h>
extern uint32_t gSysClk;

// Synchronization primitives shared by tasks
extern SemaphoreHandle_t xMutexLCD;   // Guards LCD access
```


### 2. Setup `main.cpp`
#### Include headers
Include the necessary headers for FreeRTOS, TivaWare, and your modules at the top of `main.cpp`:

```c
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

extern "C" {
   //FreeRTOS headers
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

   //TivaWare headers
#include "driverlib/sysctl.h"
#include "driverlib/fpu.h"
#include "grlib/grlib.h"
}
   // For random fruit placement (use rand/srand from <stdlib.h>)
   // Application modules
#include "app_objects.h"
#include "buzzer.h"
#include "game.h"
#include "display.h"

// Custom board drivers
#include "joystick.h"
#include "button.h"
```
#### Mutex Creation

Define the mutex as a global variable, include `semphr.h` in `main.cpp`, and create the mutex before starting tasks:
```c
extern "C" {
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h" // Include for semaphore functions
}

SemaphoreHandle_t xMutexLCD = nullptr;

void main(void) {
   // System initialization code...

   // Create the mutex before starting tasks
   xMutexLCD = xSemaphoreCreateMutex();


   // Create tasks...
   // Start the scheduler...
}
```


#### Create tasks in `main.cpp`
We recommend the following tasks as a starting point for your Snake game; feel free to adjust as needed:

| Task | Role | Period (ms) |
|------|------|-------------|
| `vInputTask` | Reads joystick and buttons. | 10 |
| `vSnakeTask` | Updates game logic and snake movement. | 150 |
| `vRenderTask` | Draws the game frame on the LCD. | 33 |
| `vBuzzerTask` | Handles sound playback using a queue. | Event-driven |

#### Suggested Priorities
The input task is critical because it must respond quickly to user actions. The snake task should also be responsive but can be slightly lower priority than input. The render and buzzer tasks can run at lower priorities since they are less time-critical. Balance priorities to ensure smooth gameplay without starving any task.

For task priorities, consider the following scheme:
| Task    | Priority |
|---------|----------|
| Input   | 2        |
| Snake   | 2        |
| Render  | 1        |
| Buzzer  | 1        |


#### Suggested Stack Sizes
The most demanding tasks are typically the render task (due to graphics operations) and the snake task (due to game logic). Input and buzzer tasks are usually lighter weight.
Start with these stack sizes; you'll optimize them in later labs.

| Task         | Suggested Stack Size (words) |
|--------------|-----------------------------|
| Input        | 512                         |
| Snake        | 512                         |
| Render       | 768                         |
| Buzzer       | 512                         |
---

### 3. Setup `buzzer.cpp` and `buzzer.h`
<Aside type="tip">
Here you can implement the buzzer functionality similar to previous labs, using a queue to send tone requests to the buzzer task.
</Aside>

Create a PWM buzzer driver with a background task that plays tones based on events received from a queue. The buzzer task should wait for tone requests and play them using PWM.

Hints for implementation:
- Include `app_objects.h` in `buzzer.cpp` to access shared objects specifically `extern uint32_t gSysClk` required for PWM configuration.
---
### 4. Setup `display.cpp` and `display.h`
Similar to previous labs, implement LCD initialization and drawing functions. The mutex is not used directly in this module; instead, tasks that call these functions must acquire the mutex first.
Implement functions to draw the snake, fruit, and score on the LCD.
We recommend the following structure for `display.h`:

<Aside type="note">
Don’t implement the logic yet.
</Aside>

```c
#pragma once

// Forward declaration for game state (defined in game.h).
struct SnakeGameState;

// Initialize LCD controller and the grlib drawing context.
void LCD_Init(void);

// Draw the full game frame: background, snake, fruit, score.
void DrawGame(const struct SnakeGameState* state);
//... other display-related declarations
```

## Snake Game Logic Overview

The Snake game is a classic arcade game where the player controls a snake that moves around a grid, trying to eat fruit to grow longer. The main rules and mechanics are:

- The snake moves in discrete steps (up, down, left, right) on a grid.
- When the snake eats a fruit, it grows longer by one segment.
- The game ends if the snake collides with itself or the wall.
- The player controls the snake's direction using a joystick.
- The goal is to eat as much fruit as possible without crashing.

In your implementation, the game logic will:
- Track the snake's position and direction.
- Detect collisions with walls or itself.
- Randomly place fruit on the grid.
- Update the score when fruit is eaten.
- Respond to user input to change direction.

## Game Logic
### Implementing Input Handling

The input task (`vInputTask`) reads the joystick and buttons to determine the snake’s direction. It updates the snake’s direction based on user input and also toggles pause/resume or requests a reset.
Create variables to hold the snake’s current direction and the game state (running, paused, reset request).

On `game.h` define the following enum and struct:

<Aside type="note">
Declare the struct type in `game.h` and export an `extern` variable so other modules can access the current state.
</Aside>

```c
// game.h
#pragma once
#include <stdbool.h>

typedef enum { UP, DOWN, LEFT, RIGHT } Direction;

typedef struct {
    Direction currentDirection;
    bool isRunning;
    bool needsReset;
} SnakeGameState;

extern SnakeGameState gameState;
```
Then on `game.cpp` define the SnakeGameState variable:

```c
#include "game.h"
SnakeGameState gameState = { RIGHT, true, false };
```
Now in `main.cpp`, in `vInputTask`, read the joystick and buttons and update the `gameState` fields accordingly.

```c
void vInputTask(void* pvParameters) {
    while (1) {
        // Read joystick and buttons
        // Update gameState.currentDirection based on joystick input
        // Update gameState.isRunning and gameState.needsReset based on button input
        //Pseudo-code example:
         if (joystick_up()) {
               gameState.currentDirection = UP;
         } else if (joystick_down()) {
               gameState.currentDirection = DOWN;
         } else if (joystick_left()) {
               gameState.currentDirection = LEFT;
         } else if (joystick_right()) {
               gameState.currentDirection = RIGHT;
         }
         if (button_pause()) {
               gameState.isRunning = !gameState.isRunning;
         }
         if (button_reset()) {
               gameState.needsReset = true;
               // Reset other game state variables as needed
         }
         vTaskDelay(pdMS_TO_TICKS(10)); // Polling interval
    }
}
```
### Snake Movement

The snake's position will be represented as an array of grid coordinates. The snake task (`vSnakeTask`) will update the snake's position based on its current direction at regular intervals. If the snake eats a fruit, it will grow longer.

Our screen size is 128×128 pixels, and we’ll use 8×8 pixels per cell. This gives us an 16×16 grid for the snake to move around. 
Each segment of the snake will occupy one cell in this grid. The snake's head will be at the front of the array, and its body will follow. When the snake moves, we will update the position of the head based on the current direction and shift the rest of the body accordingly.

<div style={{ display: "flex", justifyContent: "center" }}>
   <img src="/assets/images/snakeGrid.png" alt="Snake Game Grid" width="300" />
</div>

### Set the grid properties in `game.h`
Define the grid and cell sizes in `game.h`, plus the maximum length of the snake. With a 128×128 screen and 8×8 cells, there are 16×16 = 256 cells total, so the snake can be at most 256 segments long.

```c
#define GRID_SIZE 16
#define CELL_SIZE 8
#define MAX_LEN   256  // Maximum snake length (16x16 grid)
```
Now to represent the snake and fruit positions we can define the following in `game.h`:

```c
struct Position { uint8_t x, y; };
extern Position snake[MAX_LEN]; // Array to hold snake segments
extern Position fruit;          // Current fruit position
extern uint8_t snakeLength;     // Current length of the snake
```
Then in `game.cpp` define the variables:

```c
#include "game.h"

Position snake[MAX_LEN];
Position fruit;
uint8_t snakeLength = 4; // Start with a snake length of 4
```
On `game.cpp`, implement the basic movement in a function called `moveSnake()`. All movement-related logic will live here.

### Implementing Snake Movement Logic

At a minimum, track the head and shift the body to follow. More advanced logic (collisions, fruit, growth) builds on this foundation.

```c
void moveSnake() {
    // Shift body first so each segment follows the previous one
    for (uint8_t i = snakeLength; i > 0; i--) {
        snake[i] = snake[i - 1];
    }

    // Now update the head position based on direction
    switch (gameState.currentDirection) {
        case UP:    snake[0].y -= 1; break;
        case DOWN:  snake[0].y += 1; break;
        case LEFT:  snake[0].x -= 1; break;
        case RIGHT: snake[0].x += 1; break;
    }
}
```

### First Integration Test
At this point, the basic logic lets you move the snake on the screen using the joystick. Make sure `vInputTask` updates the direction correctly. Next, make the snake advance over time in `vSnakeTask` and draw the current frame in `vRenderTask`.

Use the following code to advance the snake in `vSnakeTask` in `main.cpp`. The task updates the game every 150 ms; this value controls the snake’s speed. Decrease it to go faster, increase it to slow down.

```c
// Advances the game periodically
void vSnakeTask(void*)
{
    ResetGame();
    for(;;){
        if (gameState.isRunning) moveSnake();
        vTaskDelay(pdMS_TO_TICKS(150));
    }
}
```

Then draw the game in `vRenderTask`. The render task runs every 33 ms and protects LCD access with the mutex.
```c
void vRenderTask(void*)
{
    LCD_Init();
    TickType_t last = xTaskGetTickCount();

    for(;;)
    {
        // Normal render
        xSemaphoreTake(xMutexLCD, portMAX_DELAY);
        DrawGame(&gameState); // Draw background, snake, fruit, score
        xSemaphoreGive(xMutexLCD);

        vTaskDelayUntil(&last, pdMS_TO_TICKS(33));
    }
}
```

By now, you should be able to steer the snake around the grid with the joystick and see it animating smoothly on the display.