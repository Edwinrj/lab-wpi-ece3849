---
title: "Lab 4: Advanced Timing, Synchronization & Performance Analysis"
description: "Master advanced FreeRTOS timing techniques, interrupt-driven synchronization, and system performance optimization through comprehensive analysis of your Snake game."
links:
- /labs/lab3/
- /guides/labtimeline/
- /guides/FreeRTOS/freertos/
tags:
  - freertos
  - timing
  - optimization
---

import { Aside } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 3"
      description="Make sure you finished Lab 3 before starting."
      href="/labs/lab3/"
      icon="setting"
   />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the list of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   /> 
</CardGrid>

---

## Objective

In this lab, you will enhance your Snake game by mastering advanced timing and synchronization techniques in FreeRTOS. You'll start by measuring timing jitter using a hardware timer to compare different delay methods (vTaskDelay vs vTaskDelayUntil) by instrumenting one task at a time and analyzing the results. You'll implement counting semaphores to buffer joystick inputs and prevent missed commands, and add a game chronometer using software timers that updates every 10ms. You'll also add new game features including wall collisions and game-over animations. Finally, you'll analyze and optimize stack usage across all tasks, display real-time performance metrics on the LCD, and implement stack overflow detection with LED alerts—ensuring your system runs efficiently within the microcontroller's memory constraints while maintaining responsive gameplay.

---

## Learning Goals

- Measure and analyze **timing jitter** using hardware timers to evaluate scheduling accuracy
- Compare **delay mechanisms** (vTaskDelay vs vTaskDelayUntil) and understand their impact on real-time behavior
- Use **counting semaphores** to buffer joystick events and prevent data loss from rapid inputs
- Create and manage **software timers** for periodic callbacks and time-keeping
- Analyze **stack usage** per task and optimize memory allocation to minimum safe values
- Implement **stack overflow detection** with hardware indicators (LED alerts)
- Display **real-time performance metrics** (timing and stack usage) on the LCD
- Apply **critical sections** correctly when accessing shared variables from timer callbacks and tasks
- Design and implement game features that stress the real-time system

---

## Grading Rubric

| Part | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | Hardware Timer Setup | Configure Timer0 for microsecond timestamp measurements | 5 |
| 2 | Baseline Timing Measurement | Measure and display jitter for three tasks using vTaskDelay | 10 |
| 3 | Timing Comparison Analysis | Convert to vTaskDelayUntil and compare results; document findings | 10 |
| 4 | Joystick Input Buffering | Implement counting semaphore for input queue; prevent reverse moves | 10 |
| 5 | Game Chronometer | Add software timer for mm:ss:cs display; start/stop/reset functionality | 10 |
| 6 | Wall Collision & Game Over | Implement deadly walls and game-over animation | 10 |
| 7 | Stack Usage Analysis | Measure per-task stack usage; optimize to safe minimums; display on LCD | 15 |
| 8 | Stack Overflow Detection | Implement detection hook with LED alert; demonstrate functionality | 5 |
|   | Lab Report | Complete analysis of timing, synchronization, and optimization decisions | 25 |
|   | **Total** |  | **100 points** |

---

## Expected Results

By the end of this lab, your system will:

- Display real-time timing metrics (average period and jitter) on the LCD
- Demonstrate measurably lower jitter using vTaskDelayUntil compared to vTaskDelay
- Buffer joystick inputs without losing rapid directional changes
- Show an accurate game chronometer (mm:ss:cs format) that pauses with the game
- End the game when the snake hits walls (no more wrap-around)
- Display a game-over animation and message when collision occurs
- Show per-task stack usage statistics on the LCD
- Trigger LED alert if any task experiences stack overflow
- Run efficiently with optimized (minimal safe) stack allocations

---

## Getting Started

### Step 1: Duplicate Your Lab 3 Project

This lab builds directly on Lab 3. Create a copy to preserve your original work:

<Steps>

1. In Code Composer Studio's Project Explorer, right-click your Lab 3 project folder
2. Select **Copy**, then right-click in an empty area and select **Paste**
3. Rename the copied project to `ece3849_lab4_<username>`
4. Set it as the active project by double-clicking on it

</Steps>

<Aside type="caution">
Close all Lab 3 files before starting Lab 4 to avoid accidentally editing the wrong project!
</Aside>

---

## Part 1: Hardware Timer for Microsecond Timestamps

### Understanding the Need

FreeRTOS tick resolution (typically 1ms) is too coarse to accurately measure task timing jitter. We need microsecond-level precision to evaluate scheduling performance.

### Implementation

**Add Required Includes** (in main.cpp):

```c
extern "C" {
#include "driverlib/timer.h"
#include "inc/hw_memmap.h"
}
#include <stdio.h>  // for snprintf
```

**Initialize Timer0 for Free-Running Count**:

```c
void Timing_Init(void)
{
    // Enable Timer0 peripheral
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0));

    // Configure as 32-bit periodic timer counting UP
    TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC_UP);
    
    // Load maximum value (free-running counter)
    TimerLoadSet(TIMER0_BASE, TIMER_A, 0xFFFFFFFF);
    
    // Start the timer
    TimerEnable(TIMER0_BASE, TIMER_A);
}
```

**Create Helper Function to Read Microseconds**:

```c
uint32_t micros(void)
{
    uint32_t ticks = TimerValueGet(TIMER0_BASE, TIMER_A);
    // Convert ticks to microseconds: system clock is 120 MHz
    return ticks / (gSysClk / 1000000);
}
```

**Call Timing_Init() in main()** before creating tasks:

```c
int main(void)
{
    // ... existing initialization ...
    
    Buzzer_Init();
    Timing_Init();  // Add this line
    
    IntMasterEnable();
    // ... create tasks ...
}
```

<Aside type="tip" title="Why Free-Running?">
A free-running counter that wraps around simplifies calculations. Unsigned arithmetic naturally handles wrap-around: if the timer wraps from 0xFFFFFFFF to 0x00000005, the subtraction `(0x00000005 - 0xFFFFFFF0) = 0x00000015` still gives the correct delta.
</Aside>

---

## Part 2: Baseline Timing Measurement

### Understanding Jitter

**Jitter** is the variation in period between consecutive task executions:

- **Ideal**: Task runs exactly every 150.000 ms
- **Reality**: 149.8ms, 150.3ms, 149.5ms, 151.2ms...
- **Jitter**: Difference from expected period (can be positive or negative)

High jitter causes:
- Jerky snake movement
- Inconsistent game speed
- Poor user experience

### Global Variables for Statistics

Add these to main.cpp (above your task functions):

```c
// Timing measurement state
volatile uint32_t last_us = 0;               // Last timestamp
volatile uint32_t min_period_us = 0xFFFFFFFF;
volatile uint32_t max_period_us = 0;
volatile uint64_t sum_period_us = 0;         // For averaging
volatile uint32_t period_count  = 0;
volatile int32_t  last_jitter_us = 0;        // Signed jitter

uint32_t expected_period_us = 10000;         // Set per task being measured
```

### Measurement Function

```c
void Timing_PeriodTick(void)
{
    uint32_t now_us = micros();
    
    if (last_us != 0)  // Skip first measurement
    {
        // Calculate actual period
        uint32_t actual_us = now_us - last_us;
        
        // Calculate jitter (signed)
        last_jitter_us = (int32_t)actual_us - (int32_t)expected_period_us;
        
        // Update statistics
        if (actual_us < min_period_us) min_period_us = actual_us;
        if (actual_us > max_period_us) max_period_us = actual_us;
        sum_period_us += actual_us;
        period_count++;
    }
    
    last_us = now_us;
}
```

### Important: Measure One Task at a Time

<Aside type="caution" title="Critical Measurement Rule">
Because all tasks share the same global timing variables, you can only measure **ONE task at a time**. If multiple tasks call `Timing_PeriodTick()`, the measurements will be meaningless.

**Procedure for each task:**
1. Add `Timing_PeriodTick()` call to ONLY ONE task
2. Set `expected_period_us` appropriately for that task
3. Run for 30 seconds and record AVG and JITTER values
4. Remove `Timing_PeriodTick()` from that task
5. Repeat for next task
</Aside>

### Measurement Procedure

You will measure three tasks: **Input**, **Snake**, and **Render**.

**Step 1: Measure Input Task (10ms period)**

Temporarily add measurement to vInputTask ONLY:

```c
static void vInputTask(void *pvParameters)
{
    (void)pvParameters;
    
    expected_period_us = INPUT_TICK_MS * 1000;  // 10ms = 10000us
    
    for (;;) {
        Timing_PeriodTick();  // Add this line
        
        // ... existing button and joystick code ...
        
        vTaskDelay(pdMS_TO_TICKS(INPUT_TICK_MS));
    }
}
```

Run your game and play for 30 seconds. Record in your report:
- Average period (AVG): _______ us
- Last jitter (JIT): _______ us

Then **remove** the `Timing_PeriodTick()` call before measuring the next task.

**Step 2: Measure Snake Task (150ms period)**

```c
static void vSnakeTask(void *pvParameters)
{
    (void)pvParameters;
    ResetGame();
    
    expected_period_us = 150000;  // 150ms
    
    for(;;) {
        Timing_PeriodTick();  // Add this line
        
        // ... existing game logic ...
        
        vTaskDelay(pdMS_TO_TICKS(150));
    }
}
```

Run and record:
- Average period: _______ us
- Last jitter: _______ us

Remove the measurement call.

**Step 3: Measure Render Task (33ms period)**

The Render task already uses `vTaskDelayUntil` - measure it anyway to see the difference:

```c
static void vRenderTask(void *pvParameters)
{
    (void)pvParameters;
    LCD_Init();
    
    TickType_t last = xTaskGetTickCount();
    expected_period_us = 33333;  // 33ms
    
    for(;;)
    {
        Timing_PeriodTick();  // Add this line
        
        // Acquire mutex before drawing
        xSemaphoreTake(xMutexLCD, portMAX_DELAY);
        DrawGame(&gameState);
        xSemaphoreGive(xMutexLCD);
        
        vTaskDelayUntil(&last, pdMS_TO_TICKS(33));
    }
}
```

Run and record:
- Average period: _______ us
- Last jitter: _______ us

<Aside type="note" title="For Your Report">
Create a table with these measurements. You'll compare them with Part 3 results where you convert Input and Snake tasks to use `vTaskDelayUntil`.
</Aside>

---

## Part 3: Timing Comparison - vTaskDelayUntil

### The Problem with vTaskDelay

`vTaskDelay(ticks)` delays for a **relative** time from when it's called. If your task's work varies (1ms one iteration, 3ms the next), the overall period varies too, causing **accumulating drift** and jitter.

### Understanding vTaskDelayUntil

`vTaskDelayUntil(&lastWakeTime, period)` delays until an **absolute** time, compensating for execution time variations and maintaining a precise period.

**Key difference:**
```
vTaskDelay:      Work(2ms) -> Delay(10ms) -> Total: 12ms
                 Work(1ms) -> Delay(10ms) -> Total: 11ms (jitter!)

vTaskDelayUntil: Work(2ms) -> Delay(8ms)  -> Total: 10ms  
                 Work(1ms) -> Delay(9ms)  -> Total: 10ms (precise!)
```

### Your Task: Convert and Compare

You need to convert your Input and Snake tasks from `vTaskDelay` to `vTaskDelayUntil` and measure the improvement.

<Aside type="tip" title="Hint: vTaskDelayUntil Pattern">
The standard pattern for `vTaskDelayUntil` is:

```c
void SomeTask(void *pvParameters)
{
    TickType_t xLastWakeTime = xTaskGetTickCount();  // Initialize ONCE
    const TickType_t xPeriod = pdMS_TO_TICKS(PERIOD_MS);
    
    for (;;) {
        // Do work here
        
        vTaskDelayUntil(&xLastWakeTime, xPeriod);  // Pass by REFERENCE
    }
}
```

Key points:
- Initialize `xLastWakeTime` before the loop
- Pass `&xLastWakeTime` (address) to the function
- The function updates `xLastWakeTime` automatically
</Aside>

**Step 1: Convert Input Task**

Modify vInputTask to use `vTaskDelayUntil` instead of `vTaskDelay`. Remember to:
1. Declare and initialize `xLastWakeTime` before the loop
2. Use the correct period in ticks
3. Pass the address of `xLastWakeTime` to the function

**Step 2: Measure Input Task Again**

Add `Timing_PeriodTick()` call (remember: measure one task at a time!):
- Run for 30 seconds
- Record Average and Jitter

**Step 3: Convert Snake Task**

Do the same conversion for vSnakeTask.

**Step 4: Measure Snake Task Again**

Measure with `Timing_PeriodTick()` and record results.

### Analysis Questions for Report

After completing your measurements, answer these in your report:

1. **Which method (vTaskDelay vs vTaskDelayUntil) produced lower jitter?** Show your data.

2. **Why does vTaskDelayUntil perform better?** Explain in terms of when the delay starts counting.

3. **Did you notice any difference in gameplay smoothness?** Be honest - sometimes the improvement is too small to feel.

4. **What is the theoretical minimum jitter you could achieve?** (Hint: Think about FreeRTOS tick resolution - what is `configTICK_RATE_HZ` set to?)

<Aside type="note" title="Expected Results">
You should see jitter reduced by 50-80% when using `vTaskDelayUntil`. Typical measurements:
- Input Task: ~500-800us jitter (down from 2000-4000us)
- Snake Task: ~800-1200us jitter (down from 3000-6000us)

The remaining jitter is limited by the 1ms tick resolution.
</Aside>

---

## Part 4: Joystick Buffering with Counting Semaphore

### The Problem: Lost Inputs

When a player makes rapid directional changes (e.g., quick left-then-up to navigate around an obstacle), the Snake task running at 150ms might only process one input before the next game tick, losing commands. This feels unresponsive and frustrating.

**Question**: How can you store multiple pending inputs without losing any?

### Understanding Counting Semaphores

Unlike a binary semaphore (0 or 1), a **counting semaphore** can count from 0 up to a maximum value. It's perfect for tracking "how many items are waiting":

```
Initial count: 0 (no inputs pending)
Input 1 arrives → Give → count: 1
Input 2 arrives → Give → count: 2
Input 3 arrives → Give → count: 3
Snake processes → Take → count: 2
Snake processes → Take → count: 1
```

### Design Challenge

You need to implement an input buffering system. Think about these questions:

1. **How many inputs should you buffer?** Too small = still lose inputs. Too large = unnecessary memory.

2. **Where do you store the actual direction values?** The semaphore only counts - it doesn't store data!

3. **How do you prevent the buffer from wrapping incorrectly?** (Hint: circular buffer with head and tail pointers)

4. **When should the Input task add to the buffer?** Every joystick read, or only on direction changes?

5. **When should the Snake task consume from the buffer?** Every game tick, or only when buffer has items?

<details>
<summary>Hint 1: Data Structure (Click to expand)</summary>

You need TWO things:
1. A **counting semaphore** to track how many inputs are pending
2. A **circular buffer** (array) to store the actual Direction values

```c
#define INPUT_BUFFER_SIZE 5

SemaphoreHandle_t xSemJoystickBuffer = NULL;
Direction inputBuffer[INPUT_BUFFER_SIZE];
volatile uint8_t bufferHead = 0;  // Where we write
volatile uint8_t bufferTail = 0;  // Where we read
```

Create the semaphore with:
```c
xSemJoystickBuffer = xSemaphoreCreateCounting(INPUT_BUFFER_SIZE, 0);
```
</details>

<details>
<summary>Hint 2: Input Task Logic (Click to expand)</summary>

Your Input task should:
1. Detect when joystick direction changes
2. Add the new direction to the buffer at `bufferHead` position
3. Increment `bufferHead` (with wrap-around: `bufferHead = (bufferHead + 1) % INPUT_BUFFER_SIZE`)
4. Signal availability by giving the semaphore: `xSemaphoreGive(xSemJoystickBuffer)`

Why only on direction *changes*? Because storing the same direction repeatedly would fill the buffer with duplicates!
</details>

<details>
<summary>Hint 3: Snake Task Consumption (Click to expand)</summary>

Your Snake task should:
1. Try to take from the semaphore (non-blocking): `if (xSemaphoreTake(xSemJoystickBuffer, 0) == pdTRUE)`
2. If successful, read from buffer at `bufferTail` position
3. Increment `bufferTail` (with wrap-around)
4. Validate the direction (no instant reverse!)
5. Apply the direction change

Use timeout of 0 (non-blocking) because the snake should move even if no new input is available.
</details>

<details>
<summary>Hint 4: Preventing Reverse Moves (Click to expand)</summary>

You already have `GetOppositeDirection()` from Lab 3. Use it to reject invalid moves:

```c
Direction bufferedDir = inputBuffer[bufferTail];
Direction opposite = GetOppositeDirection(gameState.currentDirection);

if (bufferedDir != opposite) {
    gameState.currentDirection = bufferedDir;  // Safe to apply
}
```

This prevents the snake from instantly reversing into itself.
</details>

### Implementation Checklist

<Steps>

1. Declare the counting semaphore handle and circular buffer (global variables)
2. Create the counting semaphore in `main()` before tasks
3. Modify **vInputTask** to detect direction changes and add to buffer
4. Modify **vSnakeTask** to consume from buffer before moving snake
5. Test with rapid joystick movements - all commands should execute

</Steps>

### Testing Your Buffer

Try these scenarios:

1. **Rapid zigzag**: Quickly move joystick left-right-left-right. Snake should execute all moves.

2. **Quick corner**: Move right, then immediately up. Both moves should happen on consecutive game ticks.

3. **Buffer overflow**: Make 10 rapid moves. First 5 should execute, rest are lost (that's okay - buffer is full).

<Aside type="caution" title="Common Mistake">
Don't add to the buffer on EVERY joystick read. Only add when the direction actually *changes*. Otherwise, you'll fill the buffer with duplicate entries!

Example: If joystick is held UP for 100ms, the Input task runs 10 times (every 10ms). Only the first detection should go in the buffer.
</Aside>

### Why This Works

- **Input Task** (fast, 10ms): Captures every direction change immediately
- **Snake Task** (slow, 150ms): Processes one buffered input per game tick
- **Counting Semaphore**: Tracks exactly how many unprocessed inputs exist
- **Circular Buffer**: Stores the actual direction values in order

Result: Responsive controls that don't drop player commands!

---

## Part 5: Game Chronometer with Software Timer

### Software Timer Concept

A **software timer** executes a callback function periodically without dedicating a full task. The timer service (daemon) task manages all timers efficiently.

### Requirements

- Display format: `MM:SS:CS` (minutes:seconds:centiseconds)
- Updates every 10ms (0.01 second = 1 centisecond)
- Pauses when game is paused
- Resets when game resets

### Implementation

**1. Add Timer Include**:

```c
extern "C" {
#include "timers.h"
}
```

**2. Declare Timer Handle and Variables**:

```c
TimerHandle_t chronoTimer = NULL;

volatile uint8_t  g_chrono_min = 0;   // 0-99
volatile uint8_t  g_chrono_sec = 0;   // 0-59
volatile uint16_t g_chrono_cs = 0;    // 0-99 (centiseconds)
```

**3. Write Timer Callback**:

```c
void chronoTimerCallback(TimerHandle_t xTimer)
{
    (void)xTimer;
    
    // Only increment if game is running
    if (gameState.isRunning && !gameState.loose) {
        g_chrono_cs++;
        if (g_chrono_cs >= 100) {
            g_chrono_cs = 0;
            g_chrono_sec++;
            if (g_chrono_sec >= 60) {
                g_chrono_sec = 0;
                g_chrono_min++;
                if (g_chrono_min >= 100) {
                    g_chrono_min = 0;  // Wrap at 99:59:99
                }
            }
        }
    }
}
```

**4. Create and Start Timer**:

```c
void setupChronometer(void) {
    chronoTimer = xTimerCreate(
        "Chrono",                    // Timer name
        pdMS_TO_TICKS(10),          // Period: 10ms
        pdTRUE,                      // Auto-reload
        NULL,                        // Timer ID (unused)
        chronoTimerCallback          // Callback function
    );
    
    if (chronoTimer != NULL) {
        xTimerStart(chronoTimer, 0);
    }
}
```

Call `setupChronometer()` in main() after creating tasks but before starting scheduler.

**5. Display Chronometer in DrawGame()**:

Modify your display.cpp to show the chronometer:

```c
void DrawGame(const SnakeGameState* state)
{
    // ... existing drawing code ...
    
    // Read chronometer with critical section
    taskENTER_CRITICAL();
    uint8_t min = g_chrono_min;
    uint8_t sec = g_chrono_sec;
    uint16_t cs = g_chrono_cs;
    taskEXIT_CRITICAL();
    
    // Format and display
    char timeStr[16];
    snprintf(timeStr, sizeof(timeStr), "%02u:%02u:%02u", min, sec, cs);
    
    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDraw(&gContext, timeStr, -1, 45, 115, false);
    
    // ... rest of drawing ...
}
```

**6. Reset Chronometer on Game Reset**:

In game.cpp's `ResetGame()` function:

```c
void ResetGame(void)
{
    // ... existing reset code ...
    
    // Reset chronometer
    taskENTER_CRITICAL();
    g_chrono_min = 0;
    g_chrono_sec = 0;
    g_chrono_cs = 0;
    taskEXIT_CRITICAL();
}
```

<Aside type="tip" title="Why Critical Sections?">
The timer callback (running in daemon task context) writes to these variables while the render task reads them. Critical sections ensure atomic access and prevent reading partially-updated values.
</Aside>

---

## Part 7: Wall Collision & Game Over Animation

### Implement Deadly Walls

Modify `moveSnake()` in game.cpp to check for wall collision:

```c
void moveSnake()
{
    // Save old head position
    Position oldHead = snake[0];
    
    // Shift body segments
    for (uint8_t i = snakeLength; i > 0; i--) {
        snake[i] = snake[i - 1];
    }
    
    // Calculate new head position (without wrap-around)
    switch (gameState.currentDirection) {
        case UP:
            snake[0].y = (oldHead.y > 0) ? (oldHead.y - 1) : oldHead.y;
            break;
        case DOWN:
            snake[0].y = (oldHead.y < GRID_SIZE - 1) ? (oldHead.y + 1) : oldHead.y;
            break;
        case LEFT:
            snake[0].x = (oldHead.x > 0) ? (oldHead.x - 1) : oldHead.x;
            break;
        case RIGHT:
            snake[0].x = (oldHead.x < GRID_SIZE - 1) ? (oldHead.x + 1) : oldHead.x;
            break;
    }
    
    // Check wall collision
    if (snake[0].x == 0 || snake[0].x == GRID_SIZE - 1 ||
        snake[0].y == 0 || snake[0].y == GRID_SIZE - 1) {
        gameState.loose = true;
        gameState.isRunning = false;
    }
}
```

### Add Game Over Animation

Create a function in display.cpp:

```c
void GameOverAnimation(void)
{
    // Flash screen red three times
    for (int i = 0; i < 3; i++) {
        tRectangle full = {0, 0, 127, 127};
        
        // Red flash
        GrContextForegroundSet(&gContext, ClrRed);
        GrRectFill(&gContext, &full);
        GrFlush(&gContext);
        vTaskDelay(pdMS_TO_TICKS(150));
        
        // Black
        GrContextForegroundSet(&gContext, ClrBlack);
        GrRectFill(&gContext, &full);
        GrFlush(&gContext);
        vTaskDelay(pdMS_TO_TICKS(150));
    }
}
```

**Call from vSnakeTask** when collision detected:

```c
if (gameState.loose) {
    if (xSemaphoreTake(xMutexLCD, pdMS_TO_TICKS(100)) == pdTRUE) {
        GameOverAnimation();
        xSemaphoreGive(xMutexLCD);
    }
}
```

**Display Game Over Screen** in DrawGame():

```c
void DrawGame(const SnakeGameState* state)
{
    if (state->loose && !state->isRunning) {
        // Clear screen
        tRectangle full = {0, 0, 127, 127};
        GrContextForegroundSet(&gContext, ClrBlack);
        GrRectFill(&gContext, &full);
        
        // Game Over text
        GrContextForegroundSet(&gContext, ClrRed);
        GrStringDrawCentered(&gContext, "GAME OVER", -1, 64, 50, false);
        
        // Instructions
        GrContextForegroundSet(&gContext, ClrWhite);
        GrStringDrawCentered(&gContext, "Press S2", -1, 64, 70, false);
        GrStringDrawCentered(&gContext, "to Reset", -1, 64, 80, false);
        
        GrFlush(&gContext);
        return;
    }
    
    // Normal game drawing...
}
```

---

## Part 8: Stack Usage Monitoring & Optimization

### Understanding Stack Usage

Each FreeRTOS task has its own stack (allocated at creation). **Stack overflow** occurs when a task uses more stack than allocated, corrupting memory and causing crashes.

### Measuring Stack Usage

FreeRTOS provides `uxTaskGetStackHighWaterMark()` which returns the minimum free stack space (in words) ever reached by a task.

**Example**:
- Task allocated 512 words
- High water mark = 120 words
- Actual usage = 512 - 120 = 392 words
- Safety margin = 120 words (23%)

### Implementation

**1. Add Stack Info Structure**:

```c
typedef struct {
    const char* name;
    UBaseType_t stackAllocated;   // Assigned size (words)
    UBaseType_t stackRemaining;   // Unused stack (words)
    uint8_t utilizationPercent;   // % used
} TaskStackInfo_t;

TaskStackInfo_t taskStacks[6];  // One per task
```

**2. Create Stack Measurement Function**:

```c
void measureStackUsage(void)
{
    TaskStatus_t taskStatusArray[10];
    UBaseType_t numTasks;
    
    // Get task information
    numTasks = uxTaskGetSystemState(taskStatusArray, 10, NULL);
    
    for (UBaseType_t i = 0; i < numTasks && i < 6; i++) {
        taskStacks[i].name = taskStatusArray[i].pcTaskName;
        
        // Get high water mark (minimum free stack)
        TaskHandle_t handle = taskStatusArray[i].xHandle;
        taskStacks[i].stackRemaining = uxTaskGetStackHighWaterMark(handle);
        
        // Estimate allocated size (you know from xTaskCreate calls)
        // For simplicity, record in a lookup table or make assumption
        taskStacks[i].stackAllocated = 512;  // Adjust per task
        
        // Calculate utilization
        uint32_t used = taskStacks[i].stackAllocated - taskStacks[i].stackRemaining;
        taskStacks[i].utilizationPercent = (used * 100) / taskStacks[i].stackAllocated;
    }
}
```

**3. Display Stack Stats**:

Modify vMonitorTask to alternate between timing and stack info:

```c
static void vMonitorTask(void *pvParameters)
{
    // ... existing code ...
    
    static uint8_t displayMode = 0;  // 0 = timing, 1 = stack
    
    for (;;) {
        vTaskDelayUntil(&xLastWakeTime, xPeriod);
        
        displayMode = !displayMode;  // Toggle every second
        
        if (xSemaphoreTake(xMutexLCD, pdMS_TO_TICKS(50)) == pdTRUE) {
            tRectangle infoRect = {0, 0, 127, 10};
            GrContextForegroundSet(&gContext, ClrBlack);
            GrRectFill(&gContext, &infoRect);
            
            char text[32];
            
            if (displayMode == 0) {
                // Display timing (as before)
                // ...
            } else {
                // Display stack usage
                measureStackUsage();
                
                snprintf(text, sizeof(text), "S:%u R:%u", 
                         taskStacks[0].stackRemaining,
                         taskStacks[1].stackRemaining);
                GrContextForegroundSet(&gContext, ClrCyan);
                GrStringDraw(&gContext, text, -1, 2, 2, false);
            }
            
            GrFlush(&gContext);
            xSemaphoreGive(xMutexLCD);
        }
        
        // ... reset statistics ...
    }
}
```

### Optimization Process

<Steps>

1. Run game for 2 minutes while playing actively
2. Record high water mark for each task
3. Calculate: Optimal Size = (Allocated - Remaining) + Safety Margin
4. Use 20-30% safety margin for production code
5. Update xTaskCreate() calls with optimized sizes
6. Test thoroughly to ensure no overflow

</Steps>

**Example Optimization**:

```
Original: xTaskCreate(vSnakeTask, "Snake", 512, ...)
Measured: 392 words used, 120 remaining
Optimal:  392 + 80 (20%) = 472 words (round to 480)
Updated:  xTaskCreate(vSnakeTask, "Snake", 480, ...)
```

<Aside type="caution">
Never optimize below measured maximum usage! Always leave safety margin for worst-case scenarios (deep recursion, larger variables on stack, etc.).
</Aside>

---

## Part 9: Stack Overflow Detection Hook

### Enable Detection in FreeRTOSConfig.h

Add or modify:

```c
#define configCHECK_FOR_STACK_OVERFLOW 2
```

Method 2 is most thorough - it checks both context switches and uses a canary pattern.

### Implement Hook Function

Add to main.cpp:

```c
extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    (void)xTask;
    
    // Turn on LED as hardware indicator
    // TM4C1294XL user LED2 (red) is on PN1
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPION));
    
    GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_1);
    GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_1, GPIO_PIN_1);  // LED ON
    
    // Display error on LCD (may fail if LCD stack overflow)
    tRectangle full = {0, 0, 127, 127};
    GrContextForegroundSet(&gContext, ClrRed);
    GrRectFill(&gContext, &full);
    
    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDrawCentered(&gContext, "STACK OVERFLOW", -1, 64, 40, false);
    GrStringDrawCentered(&gContext, pcTaskName, -1, 64, 60, false);
    
    GrFlush(&gContext);
    
    // Halt system - overflow is unrecoverable
    IntMasterDisable();
    while(1);
}
```

### Testing the Hook

Intentionally cause overflow to verify detection works:

```c
// Add to any task temporarily:
void causeStackOverflow(void) {
    volatile char bigArray[2000];  // Way too large
    bigArray[0] = 1;  // Prevent optimization
}
```

Expected behavior:
- LED turns red
- LCD shows "STACK OVERFLOW" and task name
- System halts

<Aside type="caution">
Remove test code before final submission! Stack overflow detection is for catching bugs during development, not normal operation.
</Aside>

---

## Final Testing Checklist

Before submitting, verify all requirements:

- Hardware timer measures and displays timing metrics on LCD
- vTaskDelayUntil reduces jitter compared to vTaskDelay (documented in report)
- Buttons respond instantly via interrupts (no polling delay)
- Rapid joystick moves are buffered and executed in order
- Chronometer displays accurate time and pauses with game
- Snake dies when hitting walls (no wrap-around)
- Game over animation displays on collision
- Stack usage shown on LCD with realistic values
- Stack overflow hook lights LED and halts system
- All tasks optimized to safe minimum stack sizes
- Code is clean and well-commented

---

## Report Requirements

Your lab report (25 points) must include:

### 1. Timing Analysis (8 points)
- Table comparing vTaskDelay vs vTaskDelayUntil measurements
- Graphs or charts showing jitter distribution
- Explanation of why vTaskDelayUntil performs better
- Discussion of tick resolution limitations

### 2. Synchronization Design (8 points)
- Explanation of binary vs counting semaphore use cases
- Justification for chosen buffer size (why 5 inputs?)
- Analysis of ISR response time vs polling
- Discussion of critical section placement for chronometer

### 3. Memory Optimization (6 points)
- Table showing stack measurements for all tasks
- Calculation of optimization percentages
- Justification for safety margins chosen
- Discussion of worst-case scenarios considered

### 4. Reflection (3 points)
- What was most challenging?
- How did testing reveal bugs?
- What would you improve given more time?

---

## Additional Resources

<CardGrid>
<LinkCard
    title="FreeRTOS Timing API"
    description="Official documentation for delay functions"
    href="https://www.freertos.org/a00127.html"
    icon="external"
/>

<LinkCard
    title="FreeRTOS Software Timers"  
    description="Guide to creating and managing timers"
    href="https://www.freertos.org/RTOS-software-timer.html"
    icon="external"
/>

<LinkCard
    title="Semaphores & Mutexes"
    description="Understanding synchronization primitives"
    href="https://www.freertos.org/a00113.html"
    icon="external"
/>

<LinkCard
    title="Stack Overflow Detection"
    description="Methods and configuration"
    href="https://www.freertos.org/Stacks-and-stack-overflow-checking.html"
    icon="external"
/>
</CardGrid>

---

## Submitting Your Work

### Export Project

<Steps>

1. Ensure your project is named `ece3849_lab4_<username>`
2. Right-click the project in Project Explorer
3. Select **Export** > **General** > **Archive File**
4. Save as `ece3849_lab4_<username>.zip`

</Steps>

### Submit to Canvas

Upload both:
- `ece3849_lab4_<username>.zip` (source code)
- `ece3849_lab4_<username>_report.pdf` (lab report)

---

Good luck optimizing your real-time system!