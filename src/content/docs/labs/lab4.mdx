---
title: "Lab 4 – RTOS Snake Game Part 2"
description: "Master advanced FreeRTOS timing techniques, interrupt-driven synchronization, and system performance optimization through comprehensive analysis of your Snake game."
links:
- /labs/lab3/
- /guides/labtimeline/
- /guides/FreeRTOS/freertos/
tags:
  - freertos
---

import { Aside } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 3"
      description="Make sure you finished Lab 3 before starting."
      href="/labs/lab3/"
      icon="setting"
   />
   <LinkCard
      title="Back to Lab Summary"
      description="Return to the list of all labs."
      href="/guides/labtimeline/"
      icon="right-arrow"
   /> 
</CardGrid>

## Objective

In this lab, you will enhance your Snake game by mastering advanced timing and synchronization techniques in FreeRTOS. You'll start by discovering the real performance characteristics of your LCD display through a hands-on timing experiment, then measure timing jitter and task execution times using a hardware timer to understand the true bottlenecks in your system. You'll implement counting semaphores to buffer joystick inputs and prevent missed commands, and add a game chronometer using software timers that updates every 10ms. You'll also add new game features including wall collisions and game-over animations. Finally, you'll analyze and optimize stack usage across all tasks, display real-time performance metrics on the LCD, and implement stack overflow detection with LED alerts—ensuring your system runs efficiently within the microcontroller's memory constraints while maintaining responsive gameplay.

---

## Learning Goals

- **Discover timing bottlenecks** through hands-on experimentation with delay mechanisms
- Measure and analyze **timing jitter** and **task execution times** using hardware timers
- Compare **delay mechanisms** (vTaskDelay vs vTaskDelayUntil) and understand their impact on real-time behavior
- **Optimize task periods** based on real performance measurements rather than assumptions
- Use **counting semaphores** to buffer joystick events and prevent data loss from rapid inputs
- Create and manage **software timers** for periodic callbacks and time-keeping
- Analyze **stack usage** per task and optimize memory allocation to minimum safe values
- Implement **stack overflow detection** with hardware indicators (LED alerts)

---

## Grading Rubric

| Part | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | Hardware Timer Setup | Configure Timer0 for microsecond timestamp measurements | 5 |
| 2 | Discovery Exercise | Experiment with vTaskDelay vs vTaskDelayUntil and document observations | 10 |
| 3 | Execution Time Measurement | Measure and analyze task execution times; find LCD drawing bottleneck | 15 |
| 4 | Jitter Analysis & Optimization | Compare timing methods and optimize task periods based on measurements | 15 |
| 5 | Game Chronometer | Add software timer for mm:ss:cs display; start/stop/reset functionality | 10 |
| 6 | Wall Collision & Game Over | Implement deadly walls and game-over animation | 10 |
| 7 | Stack Usage Analysis | Measure per-task stack usage; optimize to safe minimums; display on LCD | 15 |
| 8 | Stack Overflow Detection | Implement detection hook with LED alert; demonstrate functionality | 5 |
|   | Lab Report | Complete analysis of timing, synchronization, and optimization decisions | 15 |
|   | **Total** |  | **100 points** |

---

## Expected Results

By the end of this lab, your system will:

- Display real-time timing metrics (average period, jitter, and execution times) on the LCD
- Demonstrate measurably lower jitter using vTaskDelayUntil compared to vTaskDelay
- Show optimized task periods based on real execution time measurements
- Buffer joystick inputs without losing rapid directional changes
- Show an accurate game chronometer (mm:ss:cs format) that pauses with the game
- End the game when the snake hits walls (no more wrap-around)
- Display a game-over animation and message when collision occurs
- Show per-task stack usage statistics on the LCD
- Trigger LED alert if any task experiences stack overflow
- Run efficiently with optimized (minimal safe) stack allocations

---

## Getting Started

### Step 1: Duplicate Your Lab 3 Project

This lab builds directly on Lab 3. Create a copy to preserve your original work:


<Steps>

1. In Code Composer Studio's Project Explorer, right-click your Lab 3 project folder
2. Select **Copy**, then right-click in an empty area and select **Paste**
3. Rename the copied project to `ece3849_lab4_<username>`
4. Set it as the active project by double-clicking on it

</Steps>


<Aside type="caution">
Close all Lab 3 files before starting Lab 4 to avoid accidentally editing the wrong project!
</Aside>

---

## Part 1: Hardware Timer for Microsecond Timestamps

### Understanding the Need

FreeRTOS tick resolution (typically 1ms) is too coarse to accurately measure task timing jitter and execution times. We need microsecond-level precision to evaluate scheduling performance and discover the real timing characteristics of our system.

### Implementation

**Add Required Includes** (in main.cpp):

```c
extern "C" {
#include "driverlib/timer.h"
#include "inc/hw_memmap.h"
#include "Crystalfontz128x128_ST7735.h"
#include "grlib/grlib.h"
}
#include <stdio.h>  // for snprintf
```

**Initialize Timer0 for Free-Running Count**:

```c
void Timing_Init(void)
{
    // Enable Timer0 peripheral
    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0));

    // Configure as 32-bit periodic timer counting UP
    TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC_UP);
    
    TimerLoadSet(TIMER0_BASE, TIMER_A, 0xFFFFFFFF);
    // Start the timer
    TimerEnable(TIMER0_BASE, TIMER_A);
}
```

**Create Helper Function to Read Microseconds**:

```c
uint32_t micros(void)
{
    uint32_t ticks = TimerValueGet(TIMER0_BASE, TIMER_A);
    // Convert ticks to microseconds: system clock is 120 MHz
    return ticks / (gSysClk / 1000000);
}
```

**Call Timing_Init() in main()** before creating tasks:

```c
int main(void)
{
    // ... existing initialization ...
    
    Buzzer_Init();
    Timing_Init();  // Add this line
    
    IntMasterEnable();
    // ... create tasks ...
}
```

<Aside type="tip" title="Why Free-Running?">
A free-running counter that wraps around simplifies calculations. Unsigned arithmetic naturally handles wrap-around: if the timer wraps from 0xFFFFFFFF to 0x00000005, the subtraction `(0x00000005 - 0xFFFFFFF0) = 0x00000015` still gives the correct delta.
</Aside>

---

## Part 2: Understanding Delay Mechanisms - A Discovery Exercise

### Current State Analysis

In your current Snake game from Lab 3, your render task probably looks something like this:

```c
static void vRenderTask(void *pvParameters)
{
    // ... initialization ...
    
    for(;;)
    {
        // Lock LCD
        xSemaphoreTake(xMutexLCD, portMAX_DELAY);
        
        // Draw game (this takes time!)
        DrawGame(&gameState);
        
        xSemaphoreGive(xMutexLCD);
        
        vTaskDelay(pdMS_TO_TICKS(33));  // Current approach: relative delay
    }
}
```

### The Problem You Might Not Notice

Run your current game for a minute and observe carefully:
1. **Does the game update smoothly or feel sluggish?**
2. **Does the snake movement feel consistent?**
3. **Does the game speed seem to vary?**

### Experiment: Switch to vTaskDelayUntil

Your first task is to **observe what happens** when you change the delay mechanism:

<Steps>

1. **Change your render task** from `vTaskDelay` to `vTaskDelayUntil`:
   ```c
   static void vRenderTask(void *pvParameters)
   {
       // ... initialization ...
       TickType_t last = xTaskGetTickCount();  // ADD THIS LINE
       
       for(;;)
       {
           // ... LCD drawing code ...
           
           // Replace this line:
           vTaskDelay(pdMS_TO_TICKS(33));
           
           // With this:
           vTaskDelayUntil(&last, pdMS_TO_TICKS(33));
       }
   }
   ```
2. Adjust the priorities of your tasks to ensure proper scheduling.
    For this lab, configure your tasks with the following priorities:

    | Task Name | Priority | Rationale |
    |-----------|----------|-----------|
    | Input Task | 4 (Highest) | Must respond immediately to user input to ensure responsive controls |
    | Render Task | 3 | Needs high priority to maintain smooth visual updates |
    | Snake Task | 2 | Game logic can tolerate slight delays without affecting user experience |
    | Buzzer Task | 2 | Audio feedback is important but not time-critical |

3. **Run the game** and observe carefully what happens

4. **Document the behavior** - what happens to the display? Does it freeze or stop updating?

</Steps>

### Critical Questions to Answer

Before proceeding, make sure you can answer these questions:

1. **What happened to the display?** Did the game freeze completely or does it still respond?
2. **Why did the system lock up?** Think about what happens when a task execution time exceeds its period in `vTaskDelayUntil`
3. **What's the fundamental difference** between `vTaskDelay` and `vTaskDelayUntil`?
4. **How was the original code "hiding" this problem?** What was actually happening with `vTaskDelay(33)`?

<Aside type="tip" title="Think About It">
`vTaskDelay(33)` means "delay for 33ms **starting from when I call this function**" - but that's **after** the task has finished all its work (drawing to LCD). 

`vTaskDelayUntil(&last, 33)` means "delay until 33ms **from the last scheduled wake-up time**" - regardless of how long the task took to execute.
</Aside>

### Understanding the Delay Mechanisms

**vTaskDelay(period)** - What you've been using:
- **Relative delay** - waits for specified time from when delay is called
- **Execution time adds up** - if task takes 10ms and delays 33ms, actual period is 43ms
- **Timing drift** - periods get longer and longer as execution time accumulates
- **Result**: Sluggish, inconsistent timing

**vTaskDelayUntil(&last, period)** - What you just tried:
- **Absolute delay** - waits until specified time from last scheduled execution
- **Compensates for execution time** - maintains consistent period regardless of task duration
- **No drift** - periods remain exactly as specified (if task doesn't overrun)
- **Result**: Smooth, consistent timing

### The Hidden Problem

The issue you may not have realized is that **drawing to the LCD takes much longer than you think!** Your 33ms target period becomes much longer in reality when using `vTaskDelay`, because:

```
Real period = Execution_Time + Delay_Time
Real period = LCD_Drawing_Time + 33ms
Real period = ??? + 33ms  (We'll measure this in Part 3!)
```

This is why the game felt sluggish with `vTaskDelay` - you weren't getting 30 FPS, you were getting much less!

---

## Part 3: Measuring Task Execution Time - The Real Discovery

### The Hypothesis

You probably noticed in Part 2 that switching to `vTaskDelayUntil` with a 33ms period caused the system to freeze completely. Why did this happen when `vTaskDelay` was working (albeit sluggishly)?

**Our hypothesis:** Drawing to the LCD takes much longer than the 33ms we assumed. With `vTaskDelay(33)`, the actual period becomes `Execution_Time + 33ms`, which works but is slow. With `vTaskDelayUntil`, if the task takes longer than 33ms to execute, it can never catch up to the scheduled wake time, causing the system to lock up.

### Let's Prove It With Data

Instead of guessing, let's measure exactly how long each task takes to execute and what the real periods are.

### Adding Global Variables for Measurement

Add these global variables to main.cpp (above your task functions):

```c
// Timing measurement state
volatile uint32_t last_us = 0;               // Last timestamp
volatile uint32_t min_period_us = 0xFFFFFFFF;
volatile uint32_t max_period_us = 0;
volatile uint64_t sum_period_us = 0;         // For averaging
volatile uint32_t period_count  = 0;
volatile int32_t  last_jitter_us = 0;        // Signed jitter

// NEW: Execution time measurement
volatile uint32_t last_exec_start_us = 0;
volatile uint32_t min_exec_us = 0xFFFFFFFF;
volatile uint32_t max_exec_us = 0;
volatile uint64_t sum_exec_us = 0;
volatile uint32_t exec_count = 0;

uint32_t expected_period_us = 33000;         // Set per task being measured

// Global shared variables for display
volatile uint32_t gAvgPeriodUs = 0;
volatile int32_t  gLastJitterSnapshot = 0;
volatile uint32_t gAvgExecUs = 0;
volatile uint32_t gMaxExecUs = 0;
```

### Enhanced Measurement Functions

Add these functions to measure both period and execution time:

```c
void Timing_PeriodTick(void)
{
    uint32_t now_us = micros();
    
    if (last_us != 0)  // Skip first measurement
    {
        // Calculate actual period
        uint32_t actual_us = now_us - last_us;
        
        // Calculate jitter (signed)
        last_jitter_us = (int32_t)actual_us - (int32_t)expected_period_us;
        
        // Update statistics
        if (actual_us < min_period_us) min_period_us = actual_us;
        if (actual_us > max_period_us) max_period_us = actual_us;
        sum_period_us += actual_us;
        period_count++;
    }
    
    last_us = now_us;
}

void Timing_ExecutionStart(void)
{
    last_exec_start_us = micros();
}

void Timing_ExecutionEnd(void)
{
    if (last_exec_start_us != 0)
    {
        uint32_t exec_time_us = micros() - last_exec_start_us;
        
        if (exec_time_us < min_exec_us) min_exec_us = exec_time_us;
        if (exec_time_us > max_exec_us) max_exec_us = exec_time_us;
        sum_exec_us += exec_time_us;
        exec_count++;
    }
}
```

### Important: Measure One Task at a Time

<Aside type="caution" title="Critical Measurement Rule">
Because all tasks share the same global timing variables, you can only measure **ONE task at a time**. If multiple tasks call these measurement functions, the results will be meaningless.

**Procedure for each task:**
1. Add measurement calls to ONLY ONE task
2. Set `expected_period_us` appropriately for that task
3. Run for 30 seconds and record all values
4. Remove measurement calls from that task
5. Repeat for next task
</Aside>

### Measuring the Render Task with vTaskDelay

Let's start by measuring your **current render task** (using `vTaskDelay`) to see the problem:

```c
static void vRenderTask(void *pvParameters)
{
    // ... initialization ...
    
    for(;;)
    {
        Timing_PeriodTick();        // Measure period between task executions
        Timing_ExecutionStart();    // Start measuring execution time
        
        // Lock LCD
        xSemaphoreTake(xMutexLCD, portMAX_DELAY);
        
        // Draw game (this takes time!)
        DrawGame(&gameState);
        
        xSemaphoreGive(xMutexLCD);
        
        Timing_ExecutionEnd();      // End measuring execution time
        
        vTaskDelay(pdMS_TO_TICKS(33));  // Your current approach
    }
}
```

### Create a Monitor Task

Add this task to display your measurements in real-time:

```c
void MonitorTask(void *arg)
{
    const TickType_t period = pdMS_TO_TICKS(1000);  // 1-second stats update
    TickType_t last = xTaskGetTickCount();
    
    for (;;)
    {
        vTaskDelayUntil(&last, period);
        
        // Copy stats from measurement functions
        uint32_t p_count = period_count;
        uint64_t p_sum   = sum_period_us;
        int32_t  jit     = last_jitter_us;
        
        uint32_t e_count = exec_count;
        uint64_t e_sum   = sum_exec_us;
        uint32_t e_max   = max_exec_us;
        
        // Compute averages
        uint32_t avg_period_us = (p_count > 0u) ? (uint32_t)(p_sum / p_count) : 0u;
        uint32_t avg_exec_us   = (e_count > 0u) ? (uint32_t)(e_sum / e_count) : 0u;
        
        // Store snapshots for render task to display
        gAvgPeriodUs        = avg_period_us;
        gLastJitterSnapshot = jit;
        gAvgExecUs          = avg_exec_us;
        gMaxExecUs          = e_max;
        
        // Reset statistics window
        min_period_us = 0xFFFFFFFFu;
        max_period_us = 0u;
        sum_period_us = 0u;
        period_count  = 0u;
        
        min_exec_us = 0xFFFFFFFFu;
        max_exec_us = 0u;
        sum_exec_us = 0u;
        exec_count  = 0u;
    }
}
```

### Display the Results
<Aside type="note">
Because only a single task writes to the display, the screen mutex is not strictly necessary; it is retained mainly for academic purposes and to support future updates where multiple tasks may need synchronized access. If only one task performs all screen writes, the mutex can be omitted.
</Aside>

Since drawing to LCD takes so much time, it's better if only the **render task** handles all LCD drawing. You'll add the timing metrics display directly into your `DrawGame` function.

**Step 1: Declare external variables in display.cpp**

At the top of your `display.cpp` file (after includes), add these extern declarations:

```c
// External timing measurement variables from main.cpp
extern volatile uint32_t gAvgPeriodUs;
extern volatile int32_t  gLastJitterSnapshot;
extern volatile uint32_t gAvgExecUs;
extern volatile uint32_t gMaxExecUs;
```

**Step 2: Add metrics display to DrawGame function**

Inside your `DrawGame` function in `display.cpp`, add the timing metrics display at the end (after drawing all game elements):

```c
void DrawGame(GameState* state)
{
    // ... existing game drawing code (snake, fruit, borders, etc.) ...
    
    // Display timing metrics at the bottom of the screen
    // In your render task, after drawing the game:
    char execText[30];
    snprintf(execText, sizeof(execText), "Ex:%lu/%lu us", gAvgExecUs, gMaxExecUs);

    char periodText[30];
    snprintf(periodText, sizeof(periodText), "P:%lu J:%ld", gAvgPeriodUs/1000, gLastJitterSnapshot/1000);

    // Bottom status bar
    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDraw(&gContext, execText, -1, 2, 112, false);
    GrStringDraw(&gContext, periodText, -1, 2, 120, false);

    #ifdef GrFlush
        GrFlush(&gContext);
    #endif
}
```

<Aside type="tip" title="Why extern?">
The `extern` keyword tells the compiler that these variables are defined elsewhere (in `main.cpp`) but need to be accessible from `display.cpp`. This avoids multiple definition errors during linking while allowing the display module to read the timing data.
</Aside>

### Create the Monitor Task in main()

```c
// In main(), after creating your other tasks:
xTaskCreate(MonitorTask, "Monitor", 512, NULL, 1, NULL);
```

### Discovery Phase 1: Measure with vTaskDelay

Run your game with the measurement code and **document these values**:

1. **Average execution time**: _____ microseconds  
2. **Maximum execution time**: _____ microseconds
3. **Average period**: _____ microseconds
4. **Expected period**: 33,000 microseconds

**Key Questions:**
- How much longer is the average period than the expected 33ms?
- Why is the period so much longer than expected?
- What does this tell you about the LCD drawing performance?

### Discovery Phase 2: Measure with vTaskDelayUntil

Now change your render task to use `vTaskDelayUntil`:

```c
uint32_t expected_period_us = 100000;         // Set per task being measured

static void vRenderTask(void *pvParameters)
{
    // ... initialization ...
    TickType_t last = xTaskGetTickCount();  // Add this
    
    for(;;)
    {
        Timing_PeriodTick();        
        Timing_ExecutionStart();    
        
        // ... LCD drawing code ...
        
        Timing_ExecutionEnd();      
        
        vTaskDelayUntil(&last, pdMS_TO_TICKS(100));  // Start with longer period
    }
}
```


**Document these values**:

1. **Average execution time**: _____ microseconds (should be similar)
2. **Average period**: _____ microseconds 
3. **Jitter**: _____ microseconds

**Key Questions:**
- How does the period compare to the expected period now?
- How does jitter compare between the two methods?
- Why can we use `vTaskDelayUntil` but need a longer period than 33ms?

### Measure Other Tasks

Repeat this measurement process for your other tasks (Input and Snake) using the same procedure. For each task:

1. **Move measurement calls** to that task only
2. **Set appropriate expected_period_us** for that task  
3. **Run for 30 seconds** and record the values
4. **Create a table** comparing execution times and periods

| Task | Execution Time (avg/max) | Period | vTaskDelay Jitter | vTaskDelayUntil Jitter |
|------|---------------------------|--------|-------------------|------------------------|
| Render | ___/___  us | ___ ms | ___ us | ___ us |
| Snake | ___/___ us | ___ ms | ___ us | ___ us |
| Input | ___/___ us | ___ ms | ___ us | ___ us |

<Aside type="note" title="LCD Bottleneck Discovery">
You'll likely discover that LCD drawing takes 45-50ms! This explains why `vTaskDelay(33)` resulted in periods of ~75ms (45ms execution + 33ms delay), making your game run at only ~13 FPS instead of the intended 30 FPS. When you switch to `vTaskDelayUntil` with a 33ms period, the system freezes because the task cannot complete in time. A realistic period of 60-70ms gives smooth, consistent performance.
</Aside>

---

## Part 4: Optimizing Periods and Understanding Jitter

### Finding the Optimal Render Period

Now that you know how long LCD drawing actually takes (45-50ms), let's find the optimal period for smooth gameplay using vTaskDelayUntil:

<Steps>

1. **Start with a safe period** - set render task period to 80ms (known to be > execution time of ~50ms)
2. **Gradually decrease** the period: 75ms, 70ms, 65ms, 60ms...
3. **Watch for jitter increase** - when jitter starts growing significantly, you've found the limit or if the game freezes
4. **Add safety margin** - use a period 10-20% larger than the minimum that works

</Steps>

<Aside type="caution" title="Don't Forget to Update expected_period_us!">
When you change the render task period, you **must also update** the `expected_period_us` variable to match. For example:
```c
uint32_t expected_period_us = 80000;  // 80ms in microseconds

static void vRenderTask(void *pvParameters)
{
    TickType_t last = xTaskGetTickCount();
    
    for(;;)
    {
        Timing_PeriodTick();        
        Timing_ExecutionStart();    
        
        // ... LCD drawing code ...
        
        Timing_ExecutionEnd();      
        
        vTaskDelayUntil(&last, pdMS_TO_TICKS(80));  // Must match expected_period_us!
    }
}
```
If these don't match, your jitter measurements will be completely wrong!
</Aside>

**Expected Results:**
- **Minimum period**: ~46-50ms (just above execution time)
- **Optimal period**: 55-60ms (with 10-15% safety margin)
- **Resulting FPS**: ~16-20 FPS (consistent and smooth)

### Understanding Jitter

**Jitter** is the variation in period between consecutive task executions:

- **Ideal**: Task runs exactly every 65.000 ms
- **Reality**: 64.8ms, 65.3ms, 64.5ms, 66.2ms...
- **Jitter**: Difference from expected period (can be positive or negative)

High jitter causes:
- Jerky snake movement
- Inconsistent game speed
- Poor user experience

### Evaluating Other Tasks for vTaskDelayUntil

Now that you have execution time data for all tasks, determine which tasks would benefit from `vTaskDelayUntil`:

**Questions to answer:**
1. **Which tasks have significant execution time relative to their period?**
   - If execution time is > 10% of period, consider `vTaskDelayUntil`
2. **Which tasks need precise timing?**
   - Game logic (Snake task) benefits from consistent timing
   - Input polling can usually tolerate more jitter
3. **Which tasks would show measurable jitter improvement, which would not?**
   - Tasks with high execution time relative to their period are more likely to benefit
   - Tasks with low execution time relative to their period may not see significant improvement

### Implement vTaskDelayUntil Where Beneficial

Convert appropriate tasks to use `vTaskDelayUntil`. For example, if your Snake task would benefit:

```c
static void vSnakeTask(void *pvParameters)
{
    (void)pvParameters;
    ResetGame();
    
    TickType_t last = xTaskGetTickCount();  // Add this
    
    for(;;) {
        // ... game logic ...
        
        // Change from vTaskDelay to vTaskDelayUntil:
        vTaskDelayUntil(&last, pdMS_TO_TICKS(150));
    }
}
```

### Final Measurements and Analysis

For your report, create a comprehensive table showing:

| Task | Execution Time (avg/max) | Period | vTaskDelay Jitter | vTaskDelayUntil Jitter | Improvement |
|------|---------------------------|--------|-------------------|------------------------|-------------|
| Render | ___/___  us | ___ ms | ___ us | ___ us | ___% |
| Snake | ___/___ us | ___ ms | ___ us | ___ us | ___% |
| Input | ___/___ us | ___ ms | ___ us | ___ us | ___% |

### Adding an FPS Counter

Now that you've optimized your timing, let's add a real-time FPS (Frames Per Second) counter to validate your performance improvements and see the direct impact of your optimizations.

### Implementation

**Add FPS tracking variables:**

```c
// Add to your global variables
volatile uint32_t gFrameCount = 0;
volatile uint32_t gCurrentFPS = 0;
```

**Modify your Render Task to count frames:**

```c
static void vRenderTask(void *pvParameters)
{
    // ... initialization ...
    TickType_t last = xTaskGetTickCount();
    
    for(;;)
    {
        Timing_PeriodTick();        
        Timing_ExecutionStart();    
        
        // ... LCD drawing code ...
        
        gFrameCount++;  // Count each frame rendered
        
        Timing_ExecutionEnd();      
        
        vTaskDelayUntil(&last, pdMS_TO_TICKS(your_optimized_period));
    }
}
```

**Enhance your Monitor Task to calculate FPS:**

```c
void MonitorTask(void *arg)
{
    const TickType_t period = pdMS_TO_TICKS(1000);  // 1-second stats update
    TickType_t last = xTaskGetTickCount();
    
    for (;;)
    {
        vTaskDelayUntil(&last, period);
        
        // Calculate FPS (frames in last second)
        gCurrentFPS = gFrameCount;
        gFrameCount = 0;  // Reset counter for next second
        
        // ... existing timing measurement code ...
        
        // Store FPS for display
        // (add to your existing global variable updates)
    }
}
```

**Display FPS along with other metrics:**

```c
// In your render task, update the display to show FPS:
char fpsText[20];
snprintf(fpsText, sizeof(fpsText), "FPS:%lu", gCurrentFPS);

char execText[30];
snprintf(execText, sizeof(execText), "Ex:%lu/%lu us", gAvgExecUs, gMaxExecUs);

// Display both metrics
tRectangle hud = {0, 112, 127, 127};
GrContextForegroundSet(&gContext, ClrBlack);
GrRectFill(&gContext, &hud);

GrContextForegroundSet(&gContext, ClrWhite);
GrStringDraw(&gContext, fpsText, -1, 2, 114, false);        // FPS on first line
GrStringDraw(&gContext, execText, -1, 2, 122, false);       // Execution time on second line

#ifdef GrFlush
    GrFlush(&gContext);
#endif
```

### FPS Analysis Questions

With your FPS counter running, answer these questions for your report:

1. **What FPS do you achieve with your optimized render period?**
   - Expected FPS = 1000ms / your_period_ms
   - Actual FPS = what your counter shows
   - Why might these differ?

2. **How does FPS compare between vTaskDelay and vTaskDelayUntil?**
   - Test both briefly and document the difference
   - Explain the relationship between jitter and FPS consistency

3. **What's your theoretical maximum FPS based on LCD execution time?**
   - Max FPS ≈ 1,000,000 / max_execution_time_us
   - How close to this theoretical limit are you?

### Performance Validation

Create a final performance summary:

```
=== Final Performance Summary ===
LCD Execution Time: _____ ms (average)
Render Period: _____ ms (configured)  
Actual FPS: _____ frames/second
Theoretical Max FPS: _____ frames/second
Efficiency: _____% (actual/theoretical)

Jitter with vTaskDelay: _____ us
Jitter with vTaskDelayUntil: _____ us
Improvement: _____% reduction in jitter
```

<Aside type="tip" title="Understanding FPS in Real-Time Systems">
In real-time systems, **consistent FPS** is often more important than **high FPS**. A steady 10 FPS feels better than variable 5-15 FPS. Your jitter measurements directly relate to FPS consistency!
</Aside>

### Hardware Optimization Challenge: Pushing Beyond Software Limits

Now that you've optimized your software and achieved the best possible performance at the task scheduling level, you've likely discovered that your theoretical maximum FPS is around **~22 FPS** (based on LCD execution time of ~45ms). 

**The question is: Can we go faster?**

Up to this point, all optimizations have been at the **software level** (task periods, scheduling, delays). But the real bottleneck is **hardware**: specifically, the speed at which pixel data is transmitted to the LCD over the **SPI bus**.

### Understanding the SPI Bottleneck

The Crystalfontz 128x128 LCD communicates with the TM4C1294 via SPI (Serial Peripheral Interface). Currently, the SPI clock is configured in `HAL_EK_TM4C1294XL_Crystalfontz128x128_ST7735.h`:

```c
#define LCD_SSI_CLOCK       15000000  // 15 MHz
```

**Why does this matter?**

- Drawing a full frame requires sending 128×128 pixels of color data
- Each pixel is 16 bits (RGB565 format)
- Total data per frame: 128 × 128 × 16 = 262,144 bits = 32,768 bytes
- At 15 MHz SPI clock: Time ≈ 32,768 bytes × 8 bits/byte ÷ 15,000,000 bits/sec ≈ **17.5 ms** (just for data transfer!)
- Add protocol overhead, command bytes, and processing → **~45ms total execution time**

### Your Challenge: Hardware Acceleration

Your task is to **increase the SPI clock frequency** to reduce LCD drawing time and achieve higher FPS.

<Steps>

1. **Research the LCD specifications**
   - Find the datasheet for the **ST7735S LCD controller** (used in Crystalfontz 128x128)
   - Determine the **maximum SPI clock frequency** the display can reliably handle
   - Typical range: 15-40 MHz, but verify with the datasheet!

2. **Research the TM4C1294 SPI capabilities**
   - Check the **TM4C1294NCPDT datasheet** (SSI module specifications)
   - Determine the **maximum SPI clock frequency** the microcontroller can generate
   - Consider: SPI clock is derived from system clock with dividers

3. **Calculate theoretical improvement**
   - If you increase SPI clock from 15 MHz to X MHz, what's the new transfer time?
   - What's the new theoretical maximum FPS?
   - Example: At 30 MHz → ~8.75ms transfer + overhead → ~35ms total → **~28 FPS**

4. **Modify the SPI clock configuration**
   - Locate the file: `HAL_EK_TM4C1294XL_Crystalfontz128x128_ST7735.h`
   - Change the `LCD_SSI_CLOCK` definition to your target frequency
   - Start conservatively (e.g., 20 MHz), then increase gradually

5. **Test for reliability**
   - Recompile and flash your code
   - Play the game for several minutes
   - Watch for display artifacts: flickering, corrupted graphics, missing pixels, color errors
   - If artifacts appear, reduce frequency slightly

6. **Measure the improvement**
   - Your timing measurements from Part 3 are still active and displaying on the LCD
   - **Observe the new LCD execution time** displayed on screen (Ex: avg/max values)
   - Document how much the execution time decreased compared to 15 MHz
   - Document the new maximum achievable FPS
   - Calculate the performance gain percentage

7. **Adjust render task timing based on new measurements**
   - Based on the new execution time shown on screen, **update your render task period**
   - Example: If execution time dropped from ~45ms to ~30ms, you can decrease period from 65ms to ~40-45ms
   - **Don't forget to update `expected_period_us`** to match your new period!
   
   ```c
   // Example: If new execution time is 30ms, use 40ms period (33% safety margin)
   uint32_t expected_period_us = 40000;  // 40ms in microseconds
   
   static void vRenderTask(void *pvParameters)
   {
       TickType_t last = xTaskGetTickCount();
       
       for(;;)
       {
           Timing_PeriodTick();        
           Timing_ExecutionStart();    
           
           // ... LCD drawing code ...
           
           gFrameCount++;
           Timing_ExecutionEnd();      
           
           vTaskDelayUntil(&last, pdMS_TO_TICKS(40));  // Match expected_period_us!
       }
   }
   ```
   
   - **Verify stability**: Run for several minutes and ensure jitter remains low
   - **Gradually optimize**: Decrease period in 5ms steps until jitter increases, then add safety margin

</Steps>

### Expected Configuration Values

Based on your research, you should find:

| Parameter | Typical Value | Your Research |
|-----------|---------------|---------------|
| **ST7735S Max SPI Clock** | 15-40 MHz | _____ MHz |
| **TM4C1294 Max SPI Clock** | 60 MHz (120 MHz / 2) | _____ MHz |
| **Safe Operating Frequency** | Lower of the two | _____ MHz |
| **Recommended Starting Point** | 20-25 MHz | _____ MHz |

<Aside type="caution" title="Important Considerations">
**Don't just set the maximum frequency!** Consider:

1. **Signal integrity**: Higher frequencies are more susceptible to noise and PCB layout issues
2. **Temperature effects**: What works at room temperature may fail when the board heats up
3. **Manufacturing variation**: Not all displays are created equal; some may handle higher frequencies better
4. **Reliability vs. performance**: For a production system, use 70-80% of maximum rated frequency
5. **Testing duration**: Display artifacts may only appear after extended operation
</Aside>



### Validation and Analysis

After optimizing the SPI clock, document:

1. **Original Performance (15 MHz)**:
   - LCD execution time: _____ ms
   - Maximum FPS: _____ 
   
2. **Optimized Performance (_____ MHz)**:
   - LCD execution time: _____ ms  
   - Maximum FPS: _____
   
3. **Improvement Calculations**:
   - Execution time reduction: _____% 
   - FPS increase: _____% 
   - New theoretical limit: _____ FPS

### Questions for Your Report

Answer these questions based on your hardware optimization:

1. **What is the maximum SPI frequency supported by the ST7735S controller?**
   - Cite the datasheet section/page number

2. **What is the maximum SPI frequency the TM4C1294 can generate?**
   - Explain how it's derived from the system clock

3. **What frequency did you choose and why?**
   - Justify your decision based on specs and testing

4. **What was the measured performance improvement?**
   - Compare execution time and FPS before/after optimization

5. **Did you observe any display artifacts? At what frequency?**
   - Describe the symptoms and how you resolved them

6. **What is the limiting factor in your final configuration?**
   - Is it the display, the microcontroller, or signal integrity?

7. **Could you push it even further? What would be needed?**
   - Consider PCB layout, cable length, power supply quality, etc.

### Hardware vs. Software Optimization: Key Insights

Document your understanding of the optimization hierarchy:

1. **Software optimization** (Parts 1-4):
   - Improved scheduling, reduced jitter
   - But couldn't break the ~22 FPS hardware limit
   
2. **Hardware optimization** (this section):
   - Addresses the root cause: data transfer speed
   - Enables significantly higher performance
   - Requires understanding hardware specifications and trade-offs

3. **System-level thinking**:
   - Always identify the **true bottleneck** before optimizing
   - Software can't overcome hardware limitations
   - But hardware changes must be validated through software measurements!

<Aside type="tip" title="Real-World Application">
This is exactly how professional embedded systems engineers work:

1. **Profile** the system to find bottlenecks (software measurement)
2. **Optimize** software first (lowest cost, lowest risk)
3. **Identify** hardware limitations (timing analysis)
4. **Research** component specifications (datasheets!)
5. **Test** hardware changes incrementally (validation)
6. **Balance** performance vs. reliability (engineering judgment)

These skills apply to any embedded project: motor controllers, audio processing, video streaming, sensor fusion, etc.
</Aside>

### Increase Game Speed

Now that you've optimized both the hardware (SPI clock) and software (task timing), your game runs much smoother with higher FPS. This opens up an exciting opportunity: **you can make the game faster!**

With the original LCD bottleneck, increasing snake speed would have made the game feel even more sluggish because the display couldn't keep up. But now that you've achieved higher FPS through hardware optimization, the display can handle faster gameplay.

Increase the snake's movement speed by **decreasing the period** of the `vSnakeTask`:

**Recommended Starting Point:** 100ms (down from 150ms)

**Why This Works Now:**
- Original setup: 13-15 FPS couldn't smoothly display fast snake movement
- Optimized setup: 25-30+ FPS can easily handle faster gameplay
- The snake now moves 1.5× faster, but the display can keep up!

**Experiment Further:**
- Try even faster speeds: 80ms, 75ms, 70ms...
- Find the sweet spot between challenge and playability
- Notice how smooth gameplay feels compared to the original sluggish version

**Questions for Your Report:**
1. What snake speed (task period) did you find most enjoyable?
2. At what speed does the game become too difficult to play?
3. How does the optimized display performance enable better gameplay?
4. Could you have achieved this speed before hardware optimization? Why not?

<Aside type="tip" title="Gameplay Balance">
Faster isn't always better! The goal is to find a speed that's **challenging but fair**. With your optimized system, you now have the freedom to experiment and find that perfect balance—something that wasn't possible before hardware optimization.
</Aside>

### Critical Insights for Your Report

Document your understanding of these key concepts:

1. **Why absolute delays matter** - when is `vTaskDelayUntil` essential vs `vTaskDelay` acceptable?
2. **The LCD bottleneck** - how did measurement reveal the true cost of display updates?
3. **Task design implications** - why is it better to have one task handle all LCD operations?
4. **Real-time system constraints** - how do execution time measurements inform period selection?
5. **Performance metrics relationship** - how do execution time, period, jitter, and FPS all relate?

---

## Part 5: Joystick Input Buffering with Counting Semaphores

### The Problem with Rapid Inputs

Currently, if a user rapidly moves the joystick (faster than the snake update period), directional changes can be lost. We need to buffer these inputs to ensure responsive gameplay.

**This problem becomes especially noticeable after optimizing your game speed in Part 4.** Now that your snake moves faster (100ms period instead of 150ms), you'll notice that input responsiveness becomes critical. With faster gameplay:
- Rapid directional changes may not register
- The snake might miss turns, causing frustrating collisions
- Input feels "laggy" or unresponsive compared to the visual update rate
- Multiple quick joystick movements get lost between snake updates

**Why does faster gameplay expose this problem?**
- Original slow snake (150ms): Players had time between movements, rarely made rapid inputs
- Optimized fast snake (100ms or less): Players need to react quickly, making multiple rapid inputs
- Without buffering: Only the most recent input is captured, earlier inputs are discarded
- Result: The game feels like it's not responding correctly to your commands

This is where **input buffering** becomes essential for a professional gaming experience.

### Understanding Counting Semaphores and Queues

Before we dive into the implementation, let's understand the synchronization mechanisms we'll use:

#### What is a Counting Semaphore?

A **counting semaphore** is a synchronization primitive that maintains an internal counter:

- **Initial count**: Can be set to any value (e.g., 0, 5, 10)
- **xSemaphoreGive()**: Increments the counter (up to the maximum)
- **xSemaphoreTake()**: Decrements the counter (blocks if counter is 0)
- **Use case**: Tracking the number of available resources or pending events

**Key difference from binary semaphores:**
- Binary semaphore: Can only be 0 or 1 (like a mutex or flag)
- Counting semaphore: Can count multiple events (0, 1, 2, 3, ..., max)

**Example scenario:**
```
Initial count = 0 (no inputs pending)
User presses joystick → xSemaphoreGive() → count = 1
User presses again   → xSemaphoreGive() → count = 2
User presses again   → xSemaphoreGive() → count = 3

Snake task calls xSemaphoreTake() → count = 2 (one input processed)
Snake task calls xSemaphoreTake() → count = 1 (another input processed)
Snake task calls xSemaphoreTake() → count = 0 (last input processed)
Snake task calls xSemaphoreTake() → BLOCKS (no inputs available)
```

#### What is a Queue?

A **queue** is a FIFO (First In, First Out) buffer that stores actual data:

- **Purpose**: Store the actual values (in our case, Direction enums)
- **Operations**: xQueueSend() adds items, xQueueReceive() retrieves items
- **Blocking behavior**: Can block if queue is full (send) or empty (receive)
- **Order preservation**: Items are retrieved in the same order they were added

**Why do we need BOTH a semaphore AND a queue?**

This is a common design pattern in RTOS programming:

1. **Queue stores the data** (UP, DOWN, LEFT, RIGHT)
2. **Counting semaphore tracks how many items are in the queue**
3. **Snake task waits on semaphore** (efficient sleeping instead of polling)
4. **When semaphore signals, snake task reads from queue**

**Analogy:**
- Queue = Mailbox (stores actual letters)
- Counting Semaphore = Counter showing "3 letters inside"
- Snake Task = Person waiting for notification before checking mailbox

**Without counting semaphore:**
```c
// BAD: Polling approach (wastes CPU)
while (1) {
    if (queue has items) {  // Constantly checking!
        read from queue
    }
    vTaskDelay(1);  // Still checking 1000 times per second!
}
```

**With counting semaphore:**
```c
// GOOD: Event-driven approach (efficient)
while (1) {
    xSemaphoreTake(xSemJoystickInput, portMAX_DELAY);  // Sleep until input!
    xQueueReceive(xQueueDirections, &direction, 0);     // Guaranteed to have data
    // Process direction
}
```

<Aside type="tip" title="Synchronization Pattern">
Using a counting semaphore + queue together is a standard RTOS pattern for **producer-consumer** scenarios:
- **Producer** (Input Task): Adds data to queue, signals semaphore
- **Consumer** (Snake Task): Waits on semaphore, reads from queue
- **Benefit**: Consumer sleeps efficiently instead of wasting CPU polling
</Aside>

### Implementation Strategy

Your task is to implement an input buffering system using the counting semaphore + queue pattern. Here's the high-level architecture:

1. **Enable counting semaphores in FreeRTOS** configuration
2. **Declare global synchronization objects** properly across files
3. **Initialize semaphore and queue** in main() before starting scheduler
4. **Producer (Input Task)**: Detect direction changes, add to queue, signal semaphore
5. **Consumer (Snake Task)**: Wait on semaphore, process all queued directions

<Steps>

1. **Enable Counting Semaphores in FreeRTOS**

   Open `FreeRTOSConfig.h` and add this configuration:
   
   ```c
   #define configUSE_COUNTING_SEMAPHORES    1
   ```
   
   This enables the counting semaphore API in FreeRTOS.

2. **Declare Global Objects in app_objects.h**

   Add these extern declarations so other files can access the synchronization objects:
   
   ```c
   extern SemaphoreHandle_t xSemJoystickInput;
   extern QueueHandle_t xQueueDirections;
   
   #define MAX_DIRECTION_BUFFER 5  // Buffer up to 5 direction changes
   ```
   
   <Aside type="note">
   The `extern` keyword declares that these variables exist elsewhere (will be defined in main.cpp) but can be accessed from any file that includes this header.
   </Aside>

3. **Define Global Objects in main.cpp**

   At the top of `main.cpp`, add the actual variable definitions:
   
   ```c
   SemaphoreHandle_t xSemJoystickInput = NULL;
   QueueHandle_t xQueueDirections = NULL;
   ```
   
   Also ensure `queue.h` is included in the `extern "C"` block:
   
   ```c
   extern "C" {
   #include "FreeRTOS.h"
   #include "task.h"
   #include "queue.h"  // Make sure this is included!
   #include "semphr.h"
   // ... other includes ...
   }
   ```

4. **Initialize Synchronization Objects in main()**

   Before starting the scheduler, create the counting semaphore and queue:
   
   ```c
   // In main(), after creating tasks but before vTaskStartScheduler():
   
   // Create counting semaphore (max count = MAX_DIRECTION_BUFFER, initial count = 0)
   xSemJoystickInput = xSemaphoreCreateCounting(MAX_DIRECTION_BUFFER, 0);
   if (xSemJoystickInput == NULL) {
       while(1);  // Creation failed - halt system
   }
   
   // Create queue to store Direction values
   xQueueDirections = xQueueCreate(MAX_DIRECTION_BUFFER, sizeof(Direction));
   if (xQueueDirections == NULL) {
       while(1);  // Creation failed - halt system
   }
   ```
   
   <Aside type="caution">
   Always check if creation succeeded! Returning NULL means insufficient heap memory.
   </Aside>

</Steps>

### Implementation Pseudocode

Now that you have the synchronization objects initialized, you need to modify your Input and Snake tasks. Here's the logic you need to implement:

#### Producer Logic (Input Task)

```
TASK: InputTask
    VARIABLE: lastDetectedDirection = CURRENT_DIRECTION
    
    LOOP forever:
        Poll joystick hardware
        
        newDirection = MapJoystickToDirection()
        
        IF newDirection changed from lastDetectedDirection:
            IF newDirection is NOT opposite of current snake direction:
                TRY to add newDirection to queue (non-blocking):
                    IF successfully added to queue:
                        Signal counting semaphore (increment count)
                        Update lastDetectedDirection
                    ELSE:
                        Drop input (queue full - prevents lag buildup)
        
        Delay for input polling period
```

**Key design decisions to implement:**

1. **Prevent reversals**: Snake can't reverse direction (e.g., can't go LEFT if currently going RIGHT)
2. **Non-blocking queue send**: Use timeout of 0 to avoid blocking if queue is full
3. **Drop old inputs**: If queue is full, drop the new input rather than blocking
4. **Track last direction**: Only queue when direction actually changes
5. **Semaphore after queue**: Only signal semaphore if data was successfully added to queue

#### Consumer Logic (Snake Task)

```
TASK: SnakeTask
    VARIABLE: lastWakeTime = current tick count
    
    LOOP forever:
        WHILE counting semaphore count > 0:
            Take one count from semaphore (non-blocking)
            IF take succeeded:
                Receive one direction from queue
                Update snake's current direction
        
        IF game is running:
            Move snake in current direction
            Check collisions
            Check fruit eating
            Update score
        
        Delay until next scheduled execution
```

**Key design decisions to implement:**

1. **Process ALL queued inputs**: Use a while loop to drain all pending directions
2. **Non-blocking semaphore take**: Check if inputs are available without blocking
3. **Synchronized access**: Semaphore count should always match queue item count
4. **Apply direction immediately**: Update current direction before moving snake
5. **Maintain timing**: Use vTaskDelayUntil to keep consistent snake speed

### Implementation Hints

<Aside type="tip" title="Critical Synchronization Pattern">
**Always maintain this relationship:**
```
Semaphore Count == Number of Items in Queue
```

For every `xQueueSend()` that succeeds, call `xSemaphoreGive()` once.
For every `xSemaphoreTake()` that succeeds, call `xQueueReceive()` once.

If these get out of sync, your system will behave incorrectly!
</Aside>

**FreeRTOS API Functions You'll Need:**

1. **xQueueSend(queue, item, timeout)**
   - Adds item to queue
   - Returns `pdPASS` if successful, `errQUEUE_FULL` if queue is full
   - Use timeout = 0 for non-blocking

2. **xQueueReceive(queue, buffer, timeout)**
   - Retrieves item from queue into buffer
   - Returns `pdPASS` if successful, `errQUEUE_EMPTY` if queue is empty
   - Use timeout = 0 for non-blocking

3. **xSemaphoreGive(semaphore)**
   - Increments semaphore count
   - Returns `pdPASS` if successful

4. **xSemaphoreTake(semaphore, timeout)**
   - Decrements semaphore count (blocks if count is 0)
   - Returns `pdPASS` if successful
   - Use timeout = 0 for non-blocking check

**Example: Checking API Return Values**

```c
Direction newDirection = UP;

// Non-blocking queue send
if (xQueueSend(xQueueDirections, &newDirection, 0) == pdPASS) {
    // Success! Data was added to queue
    xSemaphoreGive(xSemJoystickInput);  // Signal that data is available
    lastDirection = newDirection;
} else {
    // Queue is full - input is dropped
}
```

```c
Direction bufferedDirection;

while (xSemaphoreTake(xSemJoystickInput, 0) == pdPASS) {
    // Semaphore was available, should be data in queue
    if (xQueueReceive(xQueueDirections, &bufferedDirection, 0) == pdPASS) {
        // Got the direction value from queue
        gameState.currentDirection = bufferedDirection;
    }
}
```

### Questions to Answer Before Implementing

Think through these questions to ensure you understand the design:

1. **Why use a counting semaphore instead of a binary semaphore?**
   - What happens if 3 inputs arrive before snake task processes them?

2. **Why use non-blocking queue operations instead of blocking?**
   - What would happen if Input Task blocked waiting for queue space?

3. **Why process ALL queued inputs in a while loop instead of just one?**
   - What happens if 5 direction changes occurred during one snake movement?

4. **Why check for opposite direction before queuing?**
   - What would happen if you allow UP→DOWN transition while moving UP?

5. **What happens if queue fills up?**
   - Should you block and wait, or drop the input? Why?

6. **Why signal semaphore AFTER successfully adding to queue?**
   - What would happen if you signal before checking if queue had space?

### Testing the Buffer

To test your input buffer:
1. Rapidly move the joystick in different directions
2. Observe that all movements are eventually processed in order
3. Verify no reverse moves are accepted
4. Try exceeding the buffer size to ensure stability

---

## Part 6: Game Chronometer with Software Timers

### Understanding Software Timers

FreeRTOS **software timers** execute callback functions at specified intervals:
- Run in timer service task context (not ISR)
- Can be one-shot or periodic
- Ideal for time-keeping and periodic operations

### Global Variables

```c
#include "timers.h"

TimerHandle_t chronoTimer = NULL;
volatile uint32_t gameTimeMs = 0;  // Total game time in milliseconds
```

### Timer Callback Function

```c
void ChronoCallback(TimerHandle_t xTimer)
{
    (void)xTimer;
    
    // Only count time when game is running
    if (gameState.isRunning) {
        gameTimeMs += 10;  // Timer fires every 10ms
    }
}
```

### Timer Creation

```c
// In main(), after creating tasks:
chronoTimer = xTimerCreate(
    "Chrono",                    // Timer name
    pdMS_TO_TICKS(10),          // 10ms period for centisecond precision  
    pdTRUE,                     // Auto-reload (periodic)
    (void*)0,                   // Timer ID (unused)
    ChronoCallback);            // Callback function

if (chronoTimer != NULL) {
    xTimerStart(chronoTimer, 0);  // Start immediately
}
```

### Display Format Function

```c
void FormatGameTime(char* buffer, size_t bufSize, uint32_t timeMs)
{
    uint32_t totalCs = timeMs / 10;        // Convert to centiseconds
    uint32_t minutes = totalCs / 6000;     // 60 sec * 100 cs = 6000 cs/min
    uint32_t seconds = (totalCs % 6000) / 100;
    uint32_t centiseconds = totalCs % 100;
    
    snprintf(buffer, bufSize, "%02lu:%02lu:%02lu", minutes, seconds, centiseconds);
}
```

### Integrate into Display

```c
// In your render task, add chronometer display:
char timeStr[12];
FormatGameTime(timeStr, sizeof(timeStr), gameTimeMs);

// Display in top area
tRectangle timeArea = {0, 0, 127, 12};
GrContextForegroundSet(&gContext, ClrBlack);
GrRectFill(&gContext, &timeArea);

GrContextForegroundSet(&gContext, ClrWhite);
GrStringDrawCentered(&gContext, timeStr, -1, 64, 6, false);
```

### Reset Functionality

```c
// In your reset game function, add:
void ResetGame(void)
{
    // ... existing reset code ...
    
    gameTimeMs = 0;  // Reset chronometer
    
    // ... rest of reset code ...
}
```

The chronometer will now:
- Display mm:ss:cs format
- Only count when game is running
- Pause when game is paused
- Reset when game is reset

---

## Part 7: Stack Usage Analysis and Optimization

### Understanding Stack Monitoring

FreeRTOS can track stack usage for each task:
- **Stack size**: Total allocated words
- **High water mark**: Maximum words used since task creation  
- **Free stack**: Current available words

### Enable Stack Monitoring

In `FreeRTOSConfig.h`, add or modify:

```c
#define configGENERATE_RUN_TIME_STATS 1
#define configUSE_TRACE_FACILITY 1
```

### Stack Monitoring Function

```c
void GetTaskStackInfo(const char* taskName, UBaseType_t* allocated, UBaseType_t* highWater)
{
    TaskHandle_t taskHandle = xTaskGetHandle(taskName);
    if (taskHandle != NULL) {
        *highWater = uxTaskGetStackHighWaterMark(taskHandle);
        
        // Get allocated size from task creation
        // Note: This requires tracking creation parameters
        // For now, use the values from your xTaskCreate calls
    }
}
```

### Monitor Task Enhancement

Modify your MonitorTask to display both timing and stack information alternately:

```c
void MonitorTask(void *arg)
{
    const TickType_t period = pdMS_TO_TICKS(1000);  
    TickType_t last = xTaskGetTickCount();
    static uint8_t displayMode = 0;  // 0 = timing, 1 = stack
    
    for (;;)
    {
        vTaskDelayUntil(&last, period);
        
        displayMode = !displayMode;  // Toggle every second
        
        if (displayMode == 0) {
            // Timing info (existing code)
            uint32_t n   = period_count;
            uint64_t sum = sum_period_us;
            int32_t  jit = last_jitter_us;
            
            uint32_t avg_us = (n > 0u) ? (uint32_t)(sum / n) : 0u;
            
            gAvgPeriodUs = avg_us;
            gLastJitterSnapshot = jit;
            
            // Reset stats
            min_period_us = 0xFFFFFFFFu;
            max_period_us = 0u;
            sum_period_us = 0u;
            period_count  = 0u;
        } else {
            // Stack info
            UBaseType_t snakeStack = uxTaskGetStackHighWaterMark(xTaskGetHandle("Snake"));
            UBaseType_t renderStack = uxTaskGetStackHighWaterMark(xTaskGetHandle("Render")); 
            UBaseType_t inputStack = uxTaskGetStackHighWaterMark(xTaskGetHandle("Input"));
            
            // Store for display
            // You'll need global variables to share this data
        }
    }
}
```

### Display Stack Information

In your render task, alternate between timing and stack displays:

```c
static uint8_t showStackInfo = 0;

// In render loop:
if (showStackInfo) {
    char stackText[30];
    snprintf(stackText, sizeof(stackText), "S:%lu R:%lu I:%lu", 
             snakeHighWater, renderHighWater, inputHighWater);
    
    // Display stack info
} else {
    // Display timing info (existing code)
}

// Toggle every few frames
static uint32_t frameCount = 0;
frameCount++;
if (frameCount > 30) {  // Switch every ~3 seconds
    showStackInfo = !showStackInfo;
    frameCount = 0;
}
```

<details>
<summary>Hint 1: Task Handle Storage (Click to expand)</summary>

Store task handles when creating tasks:
```c
TaskHandle_t xSnakeTask, xRenderTask, xInputTask;

xTaskCreate(vSnakeTask, "Snake", 512, NULL, 2, &xSnakeTask);
xTaskCreate(vRenderTask, "Render", 768, NULL, 1, &xRenderTask);
xTaskCreate(vInputTask, "Input", 512, NULL, 3, &xInputTask);
```
</details>

<details>
<summary>Hint 2: Understanding High Water Mark (Click to expand)</summary>

High water mark = **minimum** free stack words since task creation.
If `uxTaskGetStackHighWaterMark()` returns 120, it means **at least 120 words are still free**.

Question: If you allocated 512 words and `remaining` is 120, how much is the task using?
Answer: 512 - 120 = 392 words
</details>

<details>
<summary>Hint 3: Toggle Display (Click to expand)</summary>

In `MonitorTask`, use a static variable to toggle:
```c
static uint8_t displayMode = 0;  // 0 = timing, 1 = stack

for (;;) {
    vTaskDelayUntil(&last, period);
    
    displayMode = !displayMode;  // Toggle every second
    
    if (displayMode == 0) {
        // Show AVG and JIT (code you already have)
    } else {
        // Show stack info for 2-3 main tasks
        // Suggested format: "S:120 R:85" (Snake:120 words, Render:85 words)
    }
}
```
</details>

<Aside type="note" title="Display Format">
You don't need to show every task — the screen is small. Show the 2-3 main tasks you created:
- Snake task
- Render task  
- Input task

Suggested format: `"S:120 R:85 I:94"` where numbers are free words (high water mark).
</Aside>

### Optimization Challenge

Now that you can measure stack usage in real-time, your challenge is to optimize:

<Steps>

1. Run the game for 2 minutes while playing actively (move a lot, eat fruit, pause/resume)
2. Observe and note the lowest high water mark you see for each task
3. Compute actual usage: `Usage = Allocated_Stack - High_Water_Mark`
4. Compute optimal size: `New = Actual_Usage + Safety_Margin`
    - Recommended margin: 20-30% for production code
5. Update `xTaskCreate()` with the new sizes
6. Test thoroughly to ensure no overflow

</Steps>

**Optimization Example**:

```
Original: xTaskCreate(vSnakeTask, "Snake", 512, ...)
Measured after 2 min: High Water Mark = 120 words
Actual usage: 512 - 120 = 392 words
With 20% margin: 392 * 1.20 = 470 words (round to 480)
Updated: xTaskCreate(vSnakeTask, "Snake", 480, ...)
```

**Questions for your report:**
1. Which task uses the most stack? Why do you think that is?
2. How much total memory did you save by optimizing?
3. Why is it important NOT to optimize right to the measured limit?

<Aside type="caution">
Never optimize below the measured maximum usage! Always leave safety margin for worst-case scenarios (deep recursion, large stack variables, nested interrupts, etc.).
</Aside>

---

## Part 8: Stack Overflow Detection Hook

### Enable Detection in FreeRTOSConfig.h

Add or modify:

```c
#define configCHECK_FOR_STACK_OVERFLOW 2
```

Method 2 is most thorough - it checks both context switches and uses a canary pattern.

### Implement Hook Function

Add to main.cpp:

```c
extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    (void)xTask;
    
    // Turn on LED as hardware indicator
    // TM4C1294XL user LED2 (red) is on PN1
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
    while(!SysCtlPeripheralReady(SYSCTL_PERIPH_GPION));
    
    GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_1);
    GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_1, GPIO_PIN_1);  // LED ON
    
    // Display error on LCD (may fail if LCD stack overflow)
    tRectangle full = {0, 0, 127, 127};
    GrContextForegroundSet(&gContext, ClrRed);
    GrRectFill(&gContext, &full);
    
    GrContextForegroundSet(&gContext, ClrWhite);
    GrStringDrawCentered(&gContext, "STACK OVERFLOW", -1, 64, 40, false);
    GrStringDrawCentered(&gContext, pcTaskName, -1, 64, 60, false);
    
    GrFlush(&gContext);
    
    // Halt system - overflow is unrecoverable
    IntMasterDisable();
    while(1);
}
```

### Testing the Hook

Intentionally cause overflow to verify detection works:

```c
// Add to any task temporarily:
void causeStackOverflow(void) {
    volatile char bigArray[2000];  // Way too large
    bigArray[0] = 1;  // Prevent optimization
}
```

Expected behavior:
- LED turns red
- LCD shows "STACK OVERFLOW" and task name
- System halts

<Aside type="caution">
Remove test code before final submission! Stack overflow detection is for catching bugs during development, not normal operation.
</Aside>

---

## Final Testing Checklist

Before submitting, verify all requirements:

- Hardware timer measures and displays timing metrics on LCD
- vTaskDelayUntil reduces jitter compared to vTaskDelay (documented in report)
- Display updates work smoothly with optimized periods based on real measurements
- Rapid joystick moves are buffered and executed in order
- Chronometer displays accurate time and pauses with game
- Snake dies when hitting walls (no wrap-around)
- Game over animation displays on collision
- Stack usage shown on LCD with realistic values
- Stack overflow hook lights LED and halts system
- All tasks optimized to safe minimum stack sizes
- Code is clean and well-commented

---

## Report Requirements

Your lab report (15 points) must include:

### 1. Discovery Exercise Results (4 points)
- Documentation of observations when switching from vTaskDelayUntil to vTaskDelay
- Explanation of why the display became sluggish
- Clear understanding of relative vs absolute delay mechanisms

### 2. Timing and Performance Analysis (5 points)
- Table showing measured execution times for all tasks
- Analysis of LCD drawing bottleneck discovery
- Justification for optimized periods based on measurements
- Comparison of jitter before and after optimization

### 3. System Design Decisions (4 points)  
- Explanation of why LCD mutex was removed
- Justification for single-task LCD drawing approach
- Analysis of task responsibility allocation
- Stack optimization calculations and safety margins

### 4. Critical Insights (2 points)
- Key lessons learned about real-time system performance
- How measurement-driven development changed your approach
- What would you improve given more time?

---

## Additional Resources

<CardGrid>
<LinkCard
    title="FreeRTOS Timing API"
    description="Official documentation for delay functions"
    href="https://www.freertos.org/a00127.html"
    icon="external"
/>

<LinkCard
    title="FreeRTOS Software Timers"  
    description="Guide to creating and managing timers"
    href="https://www.freertos.org/RTOS-software-timer.html"
    icon="external"
/>

<LinkCard
    title="Semaphores & Mutexes"
    description="Understanding synchronization primitives"
    href="https://www.freertos.org/a00113.html"
    icon="external"
/>

<LinkCard
    title="Stack Overflow Detection"
    description="Methods and configuration"
    href="https://www.freertos.org/Stacks-and-stack-overflow-checking.html"
    icon="external"
/>
</CardGrid>

---

## Submitting Your Work

### Export Project

<Steps>

1. Ensure your project is named `ece3849_lab4_<username>`
2. Right-click the project in Project Explorer
3. Select **Export** > **General** > **Archive File**
4. Save as `ece3849_lab4_<username>.zip`

</Steps>

### Submit to Canvas

Upload both:
- `ece3849_lab4_<username>.zip` (source code)
- `ece3849_lab4_<username>_report.pdf` (lab report)

---

Good luck optimizing your real-time system!