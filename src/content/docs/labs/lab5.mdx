---
title: "Lab 5: FreeRTOS System Monitoring & Optimization"
description: "Discover hidden performance bottlenecks and learn professional debugging techniques by adding system monitoring to your Snake game."
links:
- /labs/lab4/
- /guides/labtimeline/
tags:
  - freertos
  - debugging
  - optimization
---

import { Aside } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 4"
      description="Working Snake game with timing measurements"
      href="/labs/lab4/"
      icon="setting"
   />
</CardGrid>

## Objective

Transform your Snake game into a **professional debugging platform** by implementing system monitoring that reveals CPU usage, memory consumption, and optimization opportunities. Learn the debugging techniques used in commercial embedded systems.

---

## Learning Goals

- **Measure CPU usage** per task using FreeRTOS runtime statistics
- **Monitor stack usage** to optimize memory allocation
- **Implement system debugging** displays for real-time monitoring
- **Understand embedded optimization** trade-offs and power management
- **Use debugging tools** built into FreeRTOS

---

## Grading Rubric

| Part | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | CPU Usage Monitoring | Enable runtime stats and calculate CPU percentage per task | 15 |
| 2 | Stack Usage Analysis | Monitor and optimize task stack sizes | 15 |
| 3 | Debug Display | Create on-screen system information display | 15 |
| 4 | Global CPU Usage Display | Show overall system CPU utilization on LCD | 10 |
| 5 | CPU Optimization | Reduce overall CPU usage and quantify improvements | 20 |
|   | **Lab Report** | Analysis of discoveries and optimizations | **25** |
|   | **Total** |  | **100 points** |

---

## Expected Results

Your enhanced Snake game will display:
- Real-time CPU usage percentage per task
- Global system CPU utilization with idle time percentage
- Stack usage monitoring with optimization recommendations  
- Debugging interface showing system health
- Quantified CPU usage reductions through task optimization

---

## Part 1: CPU Usage Monitoring - The Discovery

### The Challenge Question

**Before starting:** Which task in your Snake game do you think uses the most CPU time?
- Input Task (joystick polling)
- Snake Task (game logic)  
- Render Task (LCD drawing)
- Monitor Task (statistics)

Write down your prediction—you'll test it!

### Enable FreeRTOS Runtime Statistics

**Step 1: Configure FreeRTOS**

Add these lines to your `FreeRTOSConfig.h`:

```c
#define configGENERATE_RUN_TIME_STATS       1
#define configUSE_STATS_FORMATTING_FUNCTIONS 1
#define configUSE_TRACE_FACILITY            1

// Use your existing Timer0 from Lab 4
extern uint32_t micros(void);
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() 
#define portGET_RUN_TIME_STATS_TIME_STAMP() micros()
```

**Step 2: Understanding the Data**

FreeRTOS tracks runtime for each task. CPU usage is calculated as:

```
CPU Usage (%) = (Task Runtime / Total Runtime) × 100
```

### Your Implementation Challenge

**Research and implement:** How do you get runtime statistics from FreeRTOS?

<details>
<summary>Hint 1: FreeRTOS Function (Click to expand)</summary>

Look up the FreeRTOS function `uxTaskGetSystemState()`. What parameters does it need?

</details>

<details>
<summary>Hint 2: Data Structure (Click to expand)</summary>

You'll need an array of `TaskStatus_t` structures. How do you allocate memory for this?

</details>

<details>
<summary>Hint 3: Calculation (Click to expand)</summary>

Each task has a `ulRunTimeCounter` field. Compare this to the total runtime to get percentages.

</details>

**Implementation Requirements:**
- Create a function that collects CPU usage for all tasks
- Store results in a simple data structure
- Call this function from your Monitor task every 2 seconds
- Display the results on LCD (you choose the format)

### Discovery Questions

After implementation:
1. **Which task actually uses the most CPU?** 
2. **How does CPU usage change when you pause the game?**
3. **Were your initial predictions correct?**

---

## Part 2: Stack Usage Analysis & Optimization

### Understanding Stack Memory

Each FreeRTOS task has a fixed stack size (set when you call `xTaskCreate`). But how much do they actually use?

**Stack High Water Mark** = Minimum free stack space since task creation

If you allocated 512 words but high water mark is 120, your task used: 512 - 120 = 392 words maximum.

### Monitor Stack Usage

**Research Challenge:** Find the FreeRTOS function that gives you stack high water marks.

<details>
<summary>Hint: Function Name (Click to expand)</summary>

Look for `uxTaskGetStackHighWaterMark()`. What parameter does it need?

</details>

### Implementation Requirements

**Step 1: Collect Stack Data**
- Monitor stack usage for your main tasks (Input, Snake, Render)
- Display high water marks on LCD
- Update every few seconds

**Step 2: Optimization Experiment**

<Steps>

1. **Run your game for 5 minutes** while playing actively
2. **Record the minimum high water mark** you observe for each task  
3. **Calculate actual usage:** `Used = Allocated - High_Water_Mark`
4. **Design new stack sizes:** `New_Size = Used + Safety_Margin`
   - Use 25% safety margin for embedded systems
5. **Update your xTaskCreate() calls** with optimized sizes
6. **Test thoroughly** to ensure no crashes

</Steps>

**Example Calculation:**
```
Original allocation: 512 words
Observed high water mark: 145 words  
Actual usage: 512 - 145 = 367 words
With 25% margin: 367 × 1.25 = 459 words
Optimized allocation: 460 words (round up)
Memory saved: 512 - 460 = 52 words per task
```

### Analysis Questions

1. **Which task uses the most stack space? Why?**
2. **How much total memory did you save?**
3. **Why is a safety margin essential in embedded systems?**

---

## Part 3: Debug Display

### Design Challenge

Create a debug display that shows system information without overwhelming the small LCD screen.

**Requirements:**
- Toggle debug mode with joystick button press
- Show CPU usage for each task with percentages
- Display stack usage and warnings  
- Use color coding (green = OK, yellow = caution, red = danger)

### Implementation Approach

**Research these concepts:**
- How to detect joystick button presses in your input task
- How to overlay debug information on your game display
- How to format text efficiently for 128x128 LCD

<details>
<summary>Hint: Debug Toggle (Click to expand)</summary>

Use a global boolean flag. Toggle it when joystick button is pressed:
```c
static bool debugMode = false;
if (joystick_button_pressed) {
    debugMode = !debugMode;
}
```

</details>

<details>
<summary>Hint: Display Layout (Click to expand)</summary>

For small screens, use compact format:
```
CPU: S:15% R:45% I:5%  
STK: S:120 R:85 I:200
```
Where S=Snake, R=Render, I=Input

</details>

**Color Coding Guidelines:**
- **CPU Usage:** > 80%=Red, > 50%=Yellow, else=Green
- **Stack:** < 50 words=Red, < 100=Yellow, else=Green

---

## Part 4: Global CPU Usage Display

### Understanding System Load

Individual task CPU usage is important, but understanding overall system load is critical for optimization. Global CPU usage shows:

**Total Active CPU Time** = Sum of all task execution times
**Idle Time** = Time when no tasks are running  
**System Utilization** = (Active Time / Total Time) × 100

### Implementation Challenge

**Research and Calculate:** How do you determine total system CPU usage?

<details>
<summary>Hint 1: FreeRTOS Idle Task (Click to expand)</summary>

FreeRTOS has a special "IDLE" task that runs when no other tasks are ready. What percentage of time does it run?

</details>

<details>
<summary>Hint 2: Runtime Counter (Click to expand)</summary>

The idle task also has a `ulRunTimeCounter`. How does this relate to total system time?

</details>

### Display Requirements

Add global CPU information to your debug display:
- **Total CPU Usage:** Percentage of time system is busy
- **Idle Time:** Percentage of time system is idle  
- **Task Count:** Number of active tasks

**Suggested Display Format:**
```
CPU: 68%  IDLE: 32%
Tasks: 4  Load: HIGH
```

### Analysis Questions

1. **What is your current overall CPU usage during gameplay?**
2. **How much idle time does your system have?**
3. **Is there room for optimization or additional features?**

**Baseline for Optimization:** Record these values before Part 5. You'll compare them after optimization.

---

## Part 5: CPU Optimization Challenge

### The Optimization Goal

Your current system likely uses more CPU than necessary. Common inefficiencies in embedded systems:
- **Polling too frequently** (Input task checking joystick every 1ms instead of 10ms)
- **Rendering unnecessarily** (Updating LCD when nothing changed)
- **Poor task periods** (Tasks running more often than needed)
- **Blocking operations** (Tasks waiting instead of yielding CPU)

### Optimization Strategies

**Strategy 1: Increase Task Periods**
Longer periods = less frequent execution = lower CPU usage
- Input task: Try 15ms or 20ms instead of 10ms
- Monitor task: Try 3000ms instead of 2000ms
- Consider user experience impact

**Strategy 2: Conditional Rendering** 
Only redraw LCD when game state actually changes
- Track if snake moved, fruit eaten, score changed
- Skip expensive LCD operations when possible

**Strategy 3: Optimize Task Priorities**
- Lower priority for non-critical tasks
- Allow higher priority tasks to preempt when needed

**Strategy 4: Reduce Polling Frequency**
- Check joystick less frequently if response time allows
- Use interrupt-driven input instead of polling (advanced)

### Implementation Requirements

<Steps>

1. **Record baseline:** Note current global CPU usage from Part 4
2. **Choose 2-3 optimization strategies** to implement
3. **Make incremental changes:** One optimization at a time  
4. **Measure after each change:** Quantify the improvement
5. **Test gameplay:** Ensure optimizations don't hurt user experience
6. **Calculate total improvement:** Final CPU usage vs. baseline

</Steps>

### Quantification Example

```
Baseline Measurement:
- Global CPU Usage: 72%
- Idle Time: 28%

After Input Task Period Change (10ms → 15ms):
- Global CPU Usage: 65%
- Improvement: 7 percentage points

After Monitor Task Period Change (2000ms → 3000ms):  
- Global CPU Usage: 63%
- Additional Improvement: 2 percentage points

Total Improvement: 72% → 63% = 9 percentage points (12.5% reduction)
```

### Trade-off Analysis

Document the trade-offs you discover:
- **Responsiveness vs. CPU Usage:** How does longer input period affect control feel?
- **Update Frequency vs. Resources:** Does slower monitoring affect debugging experience?
- **Performance vs. Power:** How would these changes affect battery life?

### Realistic Expectations

Typical improvements in well-designed embedded systems:
- 5-15% CPU usage reduction through period optimization
- 10-25% reduction through conditional rendering
- 3-8% reduction through priority adjustments

Do not expect dramatic improvements if your Lab 4 implementation was already efficient.

### Validation Requirements

**Functionality Testing:**
- Game still plays smoothly
- All buttons and joystick respond appropriately  
- Display updates correctly
- No crashes or system instability

**Performance Testing:**
- Run optimized game for 10 minutes
- Monitor CPU usage throughout
- Verify improvement is sustained

---

### Stack Overflow Protection

#### Enable Built-in Protection

**Add to FreeRTOSConfig.h:**
```c
#define configCHECK_FOR_STACK_OVERFLOW 2
```

This enables automatic stack overflow detection.

#### Implement Emergency Handler

**Research:** Look up `vApplicationStackOverflowHook()`. What happens when FreeRTOS detects overflow?

**Your Implementation:**
- Turn on the TM4C1294XL's red LED (GPIO PN1)
- Display error message on LCD
- Halt the system safely

<details>
<summary>Hint: Hook Function Signature (Click to expand)</summary>

```c
extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    // Your emergency response here
}
```

</details>

#### Test Your Protection

**Temporary test code** (remove after testing):
```c
// Add to any task temporarily:
volatile char bigArray[1000];  // Intentionally too large
bigArray[0] = 1;  // Prevent optimization
```

**Expected behavior:** Red LED + error display + system halt

<Aside type="caution">
Remove test code before submission! This is just to verify your protection works.
</Aside>

---

## Power Management Concepts (Optional Reading)

### Understanding Power in Embedded Systems

**Key Concept:** CPU idle time = power saving opportunities

When no tasks are ready to run, FreeRTOS can:
- Stop unnecessary clock cycles
- Enter low-power sleep modes
- Wake up only when needed

### FreeRTOS Power Features

**Tickless Idle Mode:** Enable with `configUSE_TICKLESS_IDLE 1`

**Idle Hook:** Function called when system is idle
```c
void vApplicationIdleHook(void) {
    // Power-saving code here
}
```

### Power Optimization Strategies

**Task Period Optimization:**
- Longer periods = less frequent execution = lower power
- Trade-off: Responsiveness vs. battery life

**Priority-Based Power Scaling:**
- Lower priority for non-critical tasks when on battery
- Dynamic frequency scaling based on workload

**Real-World Example:** Smartphone adjusts screen refresh rate based on content and battery level.

### Discussion Questions

1. **How could you modify your Snake game for better battery life?**
2. **What tasks could run less frequently during idle periods?**
3. **How would you detect when the system is "idle" vs. "active"?**

<Aside type="note" title="Measurement Note">
You won't measure actual power consumption in this lab, but understanding these concepts is crucial for battery-powered embedded systems.
</Aside>

---
