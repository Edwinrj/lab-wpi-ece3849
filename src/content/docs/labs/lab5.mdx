---
title: "Lab 5: FreeRTOS System Monitoring & Optimization"
description: "Discover hidden performance bottlenecks and learn professional debugging techniques by adding system monitoring to your Snake game."
links:
- /labs/lab4/
- /guides/labtimeline/
tags:
  - freertos
  - debugging
  - optimization
---

import { Aside } from '@astrojs/starlight/components';
import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## Prerequisites

<CardGrid>
   <LinkCard
      title="Complete Lab 4"
      description="Working Snake game with timing measurements"
      href="/labs/lab4/"
      icon="setting"
   />
</CardGrid>

## Objective

Build on your Lab 4 Snake game by adding system monitoring capabilities to track CPU usage, stack memory consumption, and task performance. You'll implement FreeRTOS runtime statistics to measure how efficiently your tasks execute and optimize memory allocation based on actual usage patterns.

---

## Learning Goals

- **Measure CPU usage** per task using FreeRTOS runtime statistics
- **Monitor stack usage** to optimize memory allocation
- **Implement system debugging** displays for real-time monitoring
- **Understand embedded optimization** trade-offs and power management
- **Use debugging tools** built into FreeRTOS

---

## Grading Rubric

| Part | Task | Description | Points |
| :--- | :--- | :----------- | :----: |
| 1 | CPU Usage Monitoring | Enable runtime stats and calculate CPU percentage per task | 15 |
| 2 | Stack Usage Analysis | Monitor and optimize task stack sizes | 15 |
| 3 | Debug Display | Create on-screen system information display | 15 |
| 4 | Global CPU Usage Display | Show overall system CPU utilization on LCD | 10 |
| 5 | CPU Optimization | Reduce overall CPU usage and quantify improvements | 20 |
|   | **Lab Report** | Analysis of discoveries and optimizations | **25** |
|   | **Total** |  | **100 points** |

---

## Expected Results

Your enhanced Snake game will display:
- Real-time CPU usage percentage per task
- Global system CPU utilization with idle time percentage
- Stack usage monitoring with optimization recommendations  
- Debugging interface showing system health
- Quantified CPU usage reductions through task optimization

---

## Part 1: CPU Usage Monitoring - The Discovery

### The Challenge Question

**Before starting:** Which task in your Snake game do you think uses the most CPU time?
- Input Task (joystick polling)
- Snake Task (game logic)  
- Render Task (LCD drawing)
- Monitor Task (statistics)

Write down your prediction—you'll test it!

### Enable FreeRTOS Runtime Statistics

**Step 1: Configure FreeRTOS**

<Aside type="caution">
Avoid redefining these macros if they already exist in your `FreeRTOSConfig.h` file. Duplicate definitions will cause errors.
</Aside>

Add these lines to your `FreeRTOSConfig.h`:

```c
#define configGENERATE_RUN_TIME_STATS 1
#define configUSE_TRACE_FACILITY     1

#define configUSE_STATS_FORMATTING_FUNCTIONS 1


#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()   // vacío
#define portGET_RUN_TIME_COUNTER_VALUE() (xTaskGetTickCount())

```

**Step 2: Understanding the Data**

FreeRTOS tracks runtime for each task. CPU usage is calculated as:

```
CPU Usage (%) = (Task Runtime / Total Runtime) × 100
```

### Your Implementation Challenge

**Research and implement:** How do you get runtime statistics from FreeRTOS?

<details>
<summary>Hint 1: FreeRTOS Function (Click to expand)</summary>

Look up the FreeRTOS function `uxTaskGetSystemState()`. What parameters does it need?

</details>

<details>
<summary>Hint 2: Data Structure (Click to expand)</summary>

You'll need an array of `TaskStatus_t` structures. How do you allocate memory for this?

</details>

<details>
<summary>Hint 3: Calculation (Click to expand)</summary>

Each task has a `ulRunTimeCounter` field. Compare this to the total runtime to get percentages.

</details>

**Implementation Requirements:**
- Create a function that collects CPU usage for all tasks
- Store results in a simple data structure
- Call this function from your Monitor task every 2 seconds
- Display the results on LCD (you choose the format)

<Aside type="note" title="Implementation Hints: Task Handles & CPU Usage">

To monitor each task, make sure you keep the task handles returned by `xTaskCreate()`:

```c
TaskHandle_t hInput  = NULL;
TaskHandle_t hSnake  = NULL;
TaskHandle_t hRender = NULL;
TaskHandle_t hMonitor = NULL;

xTaskCreate(vInputTask,  "Input",  512, NULL, 4, &hInput);
xTaskCreate(vSnakeTask,  "Snake",  512, NULL, 2, &hSnake);
xTaskCreate(vRenderTask, "Render", 768, NULL, 3, &hRender);
xTaskCreate(MonitorTask, "Monitor", 512, NULL, 1, &hMonitor);
```

One possible approach for CPU usage is:

1. Define a small struct and a global array to store results:

```c
#define MAX_TASKS 10

typedef struct {
    char     name[16];      // Task name (truncated)
    uint32_t runtime;       // Raw runtime counter
    uint8_t  cpuPercent;    // Computed CPU %
} TaskCpuInfo;

TaskCpuInfo gTaskCpuInfo[MAX_TASKS];
uint8_t gNumTasks = 0;
```

2. In a helper function called from your Monitor task, use `uxTaskGetSystemState()` to fill an array of `TaskStatus_t`, accumulate the total runtime, and then compute percentages:

```c
void CollectCPUUsage(void)
{
    UBaseType_t numTasks = uxTaskGetNumberOfTasks();
    TaskStatus_t *taskArray;

    if (numTasks > MAX_TASKS) numTasks = MAX_TASKS;

    taskArray = (TaskStatus_t *) pvPortMalloc(numTasks * sizeof(TaskStatus_t));
    if (taskArray == NULL) return;

    uint32_t totalRuntime = 0;

    numTasks = uxTaskGetSystemState(taskArray, numTasks, &totalRuntime);

    if (totalRuntime == 0) totalRuntime = 1;   // avoid divide-by-zero

    gNumTasks = numTasks;

    for (UBaseType_t i = 0; i < numTasks; i++)
    {
        strncpy(gTaskCpuInfo[i].name, taskArray[i].pcTaskName, 15);
        gTaskCpuInfo[i].name[15] = '\0';

        gTaskCpuInfo[i].runtime = taskArray[i].ulRunTimeCounter;

        gTaskCpuInfo[i].cpuPercent =
            (uint8_t)((taskArray[i].ulRunTimeCounter * 100ULL) / totalRuntime);
    }

    vPortFree(taskArray);
}
```

You can then have your render/debug code iterate over `gTaskCpuInfo` and draw the task names and percentages on the LCD.

</Aside>

### Discovery Questions

After implementation:
1. **Which task actually uses the most CPU?** 
2. **How does CPU usage change when you pause the game?**
3. **Were your initial predictions correct?**

---

## Part 2: Stack Usage Analysis & Optimization

### Understanding Stack Memory

Each FreeRTOS task has a fixed stack size (set when you call `xTaskCreate`). But how much do they actually use?

**Stack High Water Mark** = Minimum free stack space since task creation

If you allocated 512 words but high water mark is 120, your task used: 512 - 120 = 392 words maximum.

### Monitor Stack Usage

**Research Challenge:** Find the FreeRTOS function that gives you stack high water marks.

<details>
<summary>Hint: Function Name (Click to expand)</summary>

Look for `uxTaskGetStackHighWaterMark()`. What parameter does it need?

</details>

### Implementation Requirements

**Step 1: Collect Stack Data**
- Monitor stack usage for your main tasks (Input, Snake, Render)
- Display high water marks on LCD
- Update every few seconds

**Step 2: Optimization Experiment**

<Steps>

1. **Run your game for 1 minute** while playing actively
2. **Record the minimum high water mark** you observe for each task  
3. **Calculate actual usage:** `Used = Allocated - High_Water_Mark`
4. **Design new stack sizes:** `New_Size = Used + Safety_Margin`
   - Use 25% safety margin for embedded systems
5. **Update your xTaskCreate() calls** with optimized sizes
6. **Test thoroughly** to ensure no crashes

</Steps>

**Example Calculation:**
```
Original allocation: 512 words
Observed high water mark: 145 words  
Actual usage: 512 - 145 = 367 words
With 25% margin: 367 × 1.25 = 459 words
Optimized allocation: 460 words (round up)
Memory saved: 512 - 460 = 52 words per task
```

<Aside type="note" title="Implementation Hints: Stack High Water Mark">

Once you have the task handles (`hInput`, `hSnake`, `hRender`, `hMonitor`), you can use `uxTaskGetStackHighWaterMark()` to see how close each task gets to a stack overflow.

Define a small struct and one instance per task:

```c
typedef struct {
    uint32_t allocated;  // words given to xTaskCreate
    uint32_t highWater;  // minimum free stack seen
    uint32_t used;       // derived: allocated - highWater
} StackInfo;

StackInfo stackInput;
StackInfo stackSnake;
StackInfo stackRender;
StackInfo stackMonitor;
```

Then, from your Monitor task, periodically collect stack information:

```c
void CollectStackUsage(void)
{
    // Must match the sizes you passed to xTaskCreate
    stackInput.allocated   = 512;
    stackSnake.allocated   = 512;
    stackRender.allocated  = 768;
    stackMonitor.allocated = 512;

    stackInput.highWater   = uxTaskGetStackHighWaterMark(hInput);
    stackSnake.highWater   = uxTaskGetStackHighWaterMark(hSnake);
    stackRender.highWater  = uxTaskGetStackHighWaterMark(hRender);
    stackMonitor.highWater = uxTaskGetStackHighWaterMark(hMonitor);

    stackInput.used   = stackInput.allocated   - stackInput.highWater;
    stackSnake.used   = stackSnake.allocated   - stackSnake.highWater;
    stackRender.used  = stackRender.allocated  - stackRender.highWater;
    stackMonitor.used = stackMonitor.allocated - stackMonitor.highWater;
}
```

Your debug display can then show, for example, `used/allocated` for each task and color‑code when `highWater` becomes too small.

</Aside>

### Analysis Questions

1. **Which task uses the most stack space? Why?**
2. **How much total memory did you save?**
3. **Why is a safety margin essential in embedded systems?**

---

## Part 3: Debug Display

### Design Challenge

Create a debug display that shows system information without overwhelming the small LCD screen.

**Requirements:**
- Toggle debug mode with joystick button press
- Show CPU usage for each task with percentages
- Display stack usage and warnings  
- Use color coding (green = OK, yellow = caution, red = danger)

### Implementation Approach

**Research these concepts:**
- How to detect joystick button presses in your input task
- How to overlay debug information on your game display
- How to format text efficiently for 128x128 LCD

<details>
<summary>Hint: Debug Toggle (Click to expand)</summary>

Use a global boolean flag. Toggle it when joystick button is pressed:
```c
static bool debugMode = false;
if (joystick_button_pressed) {
    debugMode = !debugMode;
}
```

</details>

<details>
<summary>Hint: Display Layout (Click to expand)</summary>

For small screens, use compact format:
```
CPU: S:15% R:45% I:5%  
STK: S:120 R:85 I:200
```
Where S=Snake, R=Render, I=Input

</details>

**Color Coding Guidelines:**
- **CPU Usage:** > 80%=Red, > 50%=Yellow, else=Green
- **Stack:** < 50 words=Red, < 100=Yellow, else=Green

---

## Part 4: Global CPU Usage Display

### Understanding System Load

Individual task CPU usage is important, but understanding overall system load is critical for optimization. Global CPU usage shows:

**Total Active CPU Time** = Sum of all task execution times
**Idle Time** = Time when no tasks are running  
**System Utilization** = (Active Time / Total Time) × 100

### Implementation Challenge

**Research and Calculate:** How do you determine total system CPU usage?

<details>
<summary>Hint 1: FreeRTOS Idle Task (Click to expand)</summary>

FreeRTOS has a special "IDLE" task that runs when no other tasks are ready. What percentage of time does it run?

</details>

<details>
<summary>Hint 2: Runtime Counter (Click to expand)</summary>

The idle task also has a `ulRunTimeCounter`. How does this relate to total system time?

</details>

### Display Requirements

Add global CPU information to your debug display:
- **Total CPU Usage:** Percentage of time system is busy
- **Idle Time:** Percentage of time system is idle  
- **Task Count:** Number of active tasks

**Suggested Display Format:**
```
CPU: 68%  IDLE: 32%
Tasks: 4  Load: HIGH
```

### Analysis Questions

1. **What is your current overall CPU usage during gameplay?**
2. **How much idle time does your system have?**
3. **Is there room for optimization or additional features?**

**Baseline for Optimization:** Record these values before Part 5. You'll compare them after optimization.

---

## Part 5: CPU Optimization Challenge

### The Optimization Goal

Your current system likely uses more CPU than necessary. Common inefficiencies in embedded systems:
- **Polling too frequently** (Input task checking joystick every 1ms instead of 10ms)
- **Rendering unnecessarily** (Updating LCD when nothing changed)
- **Poor task periods** (Tasks running more often than needed)
- **Blocking operations** (Tasks waiting instead of yielding CPU)

### Optimization Strategies

**Strategy 1: Increase Task Periods**
Longer periods = less frequent execution = lower CPU usage
- Input task: Try 15ms or 20ms instead of 10ms
- Monitor task: Try 3000ms instead of 2000ms
- Consider user experience impact

**Strategy 2: Conditional Rendering** 
Only redraw LCD when game state actually changes
- Track if snake moved, fruit eaten, score changed
- Skip expensive LCD operations when possible

**Strategy 3: Optimize Task Priorities**
- Lower priority for non-critical tasks
- Allow higher priority tasks to preempt when needed

**Strategy 4: Reduce Polling Frequency**
- Check joystick less frequently if response time allows
- Use interrupt-driven input instead of polling (advanced)

### Implementation Requirements

<Steps>

1. **Record baseline:** Note current global CPU usage from Part 4
2. **Choose 2-3 optimization strategies** to implement
3. **Make incremental changes:** One optimization at a time  
4. **Measure after each change:** Quantify the improvement
5. **Test gameplay:** Ensure optimizations don't hurt user experience
6. **Calculate total improvement:** Final CPU usage vs. baseline

</Steps>

### Quantification Example

```
Baseline Measurement:
- Global CPU Usage: 72%
- Idle Time: 28%

After Input Task Period Change (10ms → 15ms):
- Global CPU Usage: 65%
- Improvement: 7 percentage points

After Monitor Task Period Change (2000ms → 3000ms):  
- Global CPU Usage: 63%
- Additional Improvement: 2 percentage points

Total Improvement: 72% → 63% = 9 percentage points (12.5% reduction)
```

### Trade-off Analysis

Document the trade-offs you discover:
- **Responsiveness vs. CPU Usage:** How does longer input period affect control feel?
- **Update Frequency vs. Resources:** Does slower monitoring affect debugging experience?
- **Performance vs. Power:** How would these changes affect battery life?

### Realistic Expectations

Typical improvements in well-designed embedded systems:
- 5-15% CPU usage reduction through period optimization
- 10-25% reduction through conditional rendering
- 3-8% reduction through priority adjustments

Do not expect dramatic improvements if your Lab 4 implementation was already efficient.

### Validation Requirements

**Functionality Testing:**
- Game still plays smoothly
- All buttons and joystick respond appropriately  
- Display updates correctly
- No crashes or system instability

**Performance Testing:**
- Run optimized game for 10 minutes
- Monitor CPU usage throughout
- Verify improvement is sustained

---

### Stack Overflow Protection

#### Enable Built-in Protection

**Add to FreeRTOSConfig.h:**
```c
#define configCHECK_FOR_STACK_OVERFLOW 2
```

This enables automatic stack overflow detection.

#### Implement Emergency Handler

**Research:** Look up `vApplicationStackOverflowHook()`. What happens when FreeRTOS detects overflow?

**Your Implementation:**
- Turn on the TM4C1294XL's red LED (GPIO PN1)
- Display error message on LCD
- Halt the system safely

<details>
<summary>Hint: Hook Function Signature (Click to expand)</summary>

```c
extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    // Your emergency response here
}
```

</details>

#### Test Your Protection

**Temporary test code** (remove after testing):
```c
// Add to any task temporarily:
volatile char bigArray[1000];  // Intentionally too large
bigArray[0] = 1;  // Prevent optimization
```

**Expected behavior:** Red LED + error display + system halt

<Aside type="caution">
Remove test code before submission! This is just to verify your protection works.
</Aside>

---

## Power Management Concepts (Optional Reading)

### Understanding Power in Embedded Systems

**Key Concept:** CPU idle time = power saving opportunities

When no tasks are ready to run, FreeRTOS can:
- Stop unnecessary clock cycles
- Enter low-power sleep modes
- Wake up only when needed

### FreeRTOS Power Features

**Tickless Idle Mode:** Enable with `configUSE_TICKLESS_IDLE 1`

**Idle Hook:** Function called when system is idle
```c
void vApplicationIdleHook(void) {
    // Power-saving code here
}
```

### Power Optimization Strategies

**Task Period Optimization:**
- Longer periods = less frequent execution = lower power
- Trade-off: Responsiveness vs. battery life

**Priority-Based Power Scaling:**
- Lower priority for non-critical tasks when on battery
- Dynamic frequency scaling based on workload

**Real-World Example:** Smartphone adjusts screen refresh rate based on content and battery level.

### Discussion Questions

1. **How could you modify your Snake game for better battery life?**
2. **What tasks could run less frequently during idle periods?**
3. **How would you detect when the system is "idle" vs. "active"?**

<Aside type="note" title="Measurement Note">
You won't measure actual power consumption in this lab, but understanding these concepts is crucial for battery-powered embedded systems.
</Aside>

---
